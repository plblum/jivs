import { AutoGenerateDataTypeCheckService } from './../src/Services/AutoGenerateDataTypeCheckService';
import { ConditionFactory } from "../src/Conditions/ConditionFactory";
import { ITextLocalizerService } from "../src/Interfaces/TextLocalizerService";
import { ValidationServices } from "../src/Services/ValidationServices";
import { CultureIdFallback } from "../src/Interfaces/DataTypeFormatterService";
import { DataTypeIdentifierService } from "../src/Services/DataTypeIdentifierService";
import { DataTypeFormatterService } from "../src/Services/DataTypeFormatterService";
import { DataTypeConverterService } from "../src/Services/DataTypeConverterService";
import { DataTypeComparerService } from "../src/Services/DataTypeComparerService";
/**
 * You must create a ValidationServices object prior to your ValidationManager.
 * It has extensive configuration options. Many have defaults.
 * However, when it comes to these, we prefer to let you choose the classes
 * you will use instead of having all available prepopulated.
 *
 * 1. Add this code to your app.
 * 2. Call createValidationServices() to return a prepared ValidationServices object.
 * 3. Create the ValidationManager. It contains a configuration object with a property called 'services',
 *    where you attach you services object.
 * 4. Initially all available classes are registered for things like conditions,
 *    formatting, converting, and more. If you prefer, review and modify to
 *    comment out those classes you won't be using.
 */
export declare function createValidationServices(): ValidationServices;
export declare function createConditionFactory(): ConditionFactory;
export declare function registerConditions(cf: ConditionFactory): void;
/**
 * Cultures that you want to localize.
 * -> Create an array of CultureIdFallback objects in configureCultures()
 */
export declare function configureCultures(): Array<CultureIdFallback>;
/**
 *  Give native types their Lookup Keys.
 *  -> Use classes that implement IDataTypeIdentifier in register()
 *
 * See see \examples\ComparingCustomDataTypeAsNumber and ComparingCustomDataTypeAsDate examples of custom DataTypeIdentifiers
 * @param dtis
 */
export declare function registerDataTypeIdentifiers(dtis: DataTypeIdentifierService): void;
/**
 * Give data types their formatters for the tokens you use within error messages,
 * like: "The value {Value} is above {Maximum}".
 * These are localized, and should support the cultures you identified earlier.
 *   -> Use classes that implement IDataTypeFormatter in register()
 * @param dtfs
 */
export declare function registerDataTypeFormatters(dtfs: DataTypeFormatterService): void;
/**
 * Give data types ways to convert their values.
 * Usually these convert their values to a number, string, or Date object.
 * Conditions compare two values automatically when they are number, string, or Date object.
 *    -> Use classes that implement IDataTypeConverter in register()
 * see \examples\ folder for numerous examples of custom DataTypeConverters.
 * @param dtcs
 */
export declare function registerDataTypeConverters(dtcs: DataTypeConverterService): void;
/**
 * Give your custom objects the ability to compare to each other.
 * Jivs already handles numbers and strings with its defaultComparer().
 *
 * This is a special case where using an IDataTypeConverter isn't enough.
 * We've provided a comparer for Booleans, because we wanted them to have
 * comparison results of Equals or NotEquals (instead of default Equals, Lessthan, GreaterThan)
 * -> Use classes that implement IDataTypeComparer in register()
 * @param dtcs
 */
export declare function registerDataTypeComparers(dtcs: DataTypeComparerService): void;
/**
 * Automatically generate Data Type Check conditions - conditions that
 * determine if the Input value can be safely transferred into the native value.
 * The system using Jivs has the responsibility to make that transfer,
 * often using conversion code, and let Jivs know by passing both
 * Input value and resulting Native value through an InputValueHost.setValues() function.
 * When the transfer fails, still call setValues() passing 'undefined' for the native value.
 *
 * By default, all data types use the DataTypeCheckCondition, which simply
 * reports an error when the native value is undefined.
 *
 * Suppose you have a string as a native value. Your transfer code may elect to
 * convert the string without taking any action beyond trimming spaces.
 * In this case, you may want to create a regular expression to parse the input value
 * and see if the content conforms to the rules.
 *
 * See \examples\EmailAddressDataType.ts for example.
 * -> Use classes that implement IDataTypeCheckGenerator in register()
 * @param ag
 */
export declare function registerDataTypeCheckGenerators(ag: AutoGenerateDataTypeCheckService): void;
export declare function createTextLocalizerService(): ITextLocalizerService;
