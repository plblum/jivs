/**
 * @inheritdoc {@link Support/CreateValidationServicesForTesting!createValidationServicesForTesting }
 * @module Support/CreateValidationServicesForTesting
 */

import {
    DataTypeCheckCondition, RequireTextCondition, RegExpCondition, RangeCondition,
    EqualToCondition, StringLengthConditionConfig, StringLengthCondition, AllMatchCondition, AllMatchConditionConfig, AnyMatchCondition,
    AnyMatchConditionConfig, CountMatchesCondition, CountMatchesConditionConfig, GreaterThanCondition, GreaterThanOrEqualCondition, LessThanCondition,
    LessThanOrEqualCondition, NotEqualToCondition, NotNullCondition, NotNullConditionConfig,
    GreaterThanOrEqualConditionConfig,
    LessThanOrEqualConditionConfig,
    GreaterThanConditionConfig,
    LessThanConditionConfig,
    NotEqualToConditionConfig,
    EqualToConditionConfig,
    EqualToValueCondition,
    EqualToValueConditionConfig,
    GreaterThanOrEqualValueCondition,
    GreaterThanOrEqualValueConditionConfig,
    GreaterThanValueCondition,
    LessThanOrEqualValueCondition,
    LessThanOrEqualValueConditionConfig,
    LessThanValueCondition,
    LessThanValueConditionConfig,
    NotEqualToValueCondition,
    NotEqualToValueConditionConfig,
    GreaterThanValueConditionConfig,
    PositiveCondition,
    PositiveConditionConfig,
    IntegerCondition,
    IntegerConditionConfig,
    MaxDecimalsCondition,
    MaxDecimalsConditionConfig
} from "../Conditions/ConcreteConditions";

import { NotCondition, NotConditionConfig } from "../Conditions/NotCondition";
import { WhenCondition, WhenConditionConfig } from "../Conditions/WhenCondition";

import { ConditionFactory } from "../Conditions/ConditionFactory";
import { ConditionType } from "../Conditions/ConditionTypes";
import {
    StringFormatter, NumberFormatter, IntegerFormatter, DateFormatter, AbbrevDOWDateFormatter, AbbrevDateFormatter,
    BooleanFormatter, CapitalizeStringFormatter, CurrencyFormatter, DateTimeFormatter, LongDOWDateFormatter, LongDateFormatter,
    LowercaseStringFormatter, Percentage100Formatter, PercentageFormatter, TimeofDayFormatter, TimeofDayHMSFormatter, UppercaseStringFormatter
} from "../DataTypes/DataTypeFormatters";
import { LoggingLevel } from "../Interfaces/LoggerService";
import { AutoGenerateDataTypeCheckService } from "../Services/AutoGenerateDataTypeCheckService";
import { ConsoleLoggerService } from "../Services/ConsoleLoggerService";
import { DataTypeComparerService } from "../Services/DataTypeComparerService";
import { DataTypeConverterService } from "../Services/DataTypeConverterService";
import { DataTypeFormatterService } from "../Services/DataTypeFormatterService";
import { DataTypeIdentifierService } from "../Services/DataTypeIdentifierService";
import { MessageTokenResolverService } from "../Services/MessageTokenResolverService";
import { TextLocalizerService } from "../Services/TextLocalizerService";
import { ValidationServices } from "../Services/ValidationServices";
import { DataTypeCheckConditionConfig, RequireTextConditionConfig, RegExpConditionConfig, RangeConditionConfig } from "../Conditions/ConcreteConditions";
import { LookupKey } from "../DataTypes/LookupKeys";
import { registerTestingOnlyConditions } from "../Support/conditionsForTesting";
import { CultureIdFallback, ICultureService } from "../Interfaces/CultureService";
import { DataTypeParserService } from "../Services/DataTypeParserService";
import { CleanUpStringParser, NumberParser } from "../DataTypes/DataTypeParsers";
import { IDataTypeParserService } from "../Interfaces/DataTypeParserService";
import { ValidatorConfigMergeService, ValueHostConfigMergeService } from "../Services/ConfigMergeService";
import { ValidationManagerConfigBuilderFactory } from "../Services/ManagerConfigBuilderFactory";
import { ValidationManagerConfigModifierFactory } from "../Services/ManagerConfigModifierFactory";
import {
    CaseInsensitiveStringConverter, DateTimeConverter, IntegerConverter, LocalDateOnlyConverter,
    NumericStringToNumberConverter, TimeOfDayHMSOnlyConverter, TimeOfDayOnlyConverter, UTCDateOnlyConverter
} from "../DataTypes/DataTypeConverters";
import { IConditionFactory } from "../Interfaces/Conditions";
import { CapturingLogger } from "./CapturingLogger";
import { IValidationServices } from "../Interfaces/ValidationServices";

/**
 * Every app should have a function like this to create the ValidationServices object.
 * They normally have one that is edited. This one is for testing and has fixed objects.
 * - It has options to determine what those objects are.
 * - By default, it uses the ConsoleLoggerService with LoggingLevel.Error.
 * - By default, it uses the culture 'en' and registers a few cultures with fallbacks.
 * - By default, it always adds the Conditions exclusively designed for testing in the conditionsForTesting.ts file.
 * - By default, it also adds DataTypeCheckCondition and RequireTextCondition to the ConditionFactory.
 *   If you want more, use options.registerConditions = 'all'.
 * - By default, it does not add any DataTypeFormatters. If you want them, use options.registerFormatters = true.
 * - By default, it adds all built-in DataTypeConverters.
 * - By default, it does not add any DataTypeParsers. If you want them, use options.registerDataTypeParsers = true.
 * @param options 
 * @returns 
 */
export function createValidationServicesForTesting(options?: CvstOptions): IValidationServices {
    if (!options) options = {};

    let vs = new ValidationServices();

    let consoleLogger = new ConsoleLoggerService(options.loggerLevel ?? LoggingLevel.Error);
    if (options.logger === 'capturing') {
        let capturingLogger = new CapturingLogger(options.loggerLevel ?? LoggingLevel.Error, consoleLogger);
        vs.loggerService = capturingLogger;
    }
    else
        vs.loggerService = consoleLogger;

    vs.cultureService.activeCultureId = options.activeCultureId ?? 'en';
    if (options.cultures)
        options.cultures.forEach((culture) => vs.cultureService.register(culture));
    else
        registerCultures(vs.cultureService);

    let cf = new ConditionFactory();
    vs.conditionFactory = cf;
    if (options.registerTestingConditions || options.registerTestingConditions === undefined)
        registerTestingOnlyConditions(cf);    
    switch (options.registerConditions ?? 'minimal')
    {
        case 'all':
            registerAllConditions(cf);
            break;
        case 'minimal':
            registerMinimalConditions(cf);
            break;
        case 'none':
            break;
    }

    // vs.valueHostFactory = unnecessary because uses ValueHostFactory with all ValueHostGenerators by default.

    let dtis = new DataTypeIdentifierService();
    vs.dataTypeIdentifierService = dtis;


    let dtfs = new DataTypeFormatterService();
    vs.dataTypeFormatterService = dtfs;
    if (options.registerFormatters)
        registerDataTypeFormatters(dtfs);

    let dtcs = new DataTypeConverterService();
    vs.dataTypeConverterService = dtcs;
    if (options.registerDataTypeConverters || options.registerDataTypeConverters === undefined)
        registerDataTypeConverters(dtcs);
    
    let dtcmps = new DataTypeComparerService();
    vs.dataTypeComparerService = dtcmps;
  

    let dtps = new DataTypeParserService();
    vs.dataTypeParserService = dtps;
    if (options.registerDataTypeParsers)
        registerDataTypeParsers(dtps);
    
    let ag = new AutoGenerateDataTypeCheckService();
    vs.autoGenerateDataTypeCheckService = ag;

    vs.textLocalizerService = new TextLocalizerService();
    vs.messageTokenResolverService = new MessageTokenResolverService();
    vs.valueHostConfigMergeService = new ValueHostConfigMergeService();
    vs.validatorConfigMergeService = new ValidatorConfigMergeService();
    vs.managerConfigBuilderFactory = new ValidationManagerConfigBuilderFactory();
    vs.managerConfigModifierFactory = new ValidationManagerConfigModifierFactory();

    return vs;
}

/**
 * Guides the creation of the ValidationServices object.
 */
export interface CvstOptions {
    activeCultureId?: string;   // defaults to en
    cultures?: Array<CultureIdFallback>;     // defaults en, en-US, es, es-MX, fr with some fallbacks
    logger?: 'console' | 'capturing';    // defaults to console. When capturing, it also logs to console.
    loggerLevel?: LoggingLevel; // defaults to Error
    registerConditions?: 'minimal' | 'all' | 'none'; // defaults to minimal which gives only RequireText and DataTypeCheck. When all, all built-in are supplied
    registerTestingConditions?: boolean; // defaults to true
    registerFormatters?: boolean;   // defaults to false
    registerDataTypeConverters?: boolean; // defaults to true
    registerDataTypeParsers?: boolean; // defaults to false

}

/**
 * Adds the RequireText and DataTypeCheck conditions to the ConditionFactory.
 * @param cf 
 */
export function registerMinimalConditions(cf: ConditionFactory): void
{
    cf.register<DataTypeCheckConditionConfig>(
        ConditionType.DataTypeCheck, (config) => new DataTypeCheckCondition(config));
    cf.register<RequireTextConditionConfig>(
        ConditionType.RequireText, (config) => new RequireTextCondition(config));
}
/**
 * Adds all built-in conditions to the ConditionFactory.
 * @param cf 
 */
export function registerAllConditions(cf: IConditionFactory): void
{
    cf.register<DataTypeCheckConditionConfig>(
        ConditionType.DataTypeCheck, (config) => new DataTypeCheckCondition(config));
    cf.register<RequireTextConditionConfig>(
        ConditionType.RequireText, (config) => new RequireTextCondition(config));
  
    cf.register<RegExpConditionConfig>(
        ConditionType.RegExp, (config) => new RegExpCondition(config));
    cf.register<RangeConditionConfig>(
        ConditionType.Range, (config) => new RangeCondition(config));
    cf.register<EqualToConditionConfig>(
        ConditionType.EqualTo, (config) => new EqualToCondition(config));
    cf.register<NotEqualToConditionConfig>
        (ConditionType.NotEqualTo, (config) => new NotEqualToCondition(config));
    cf.register<GreaterThanConditionConfig>
        (ConditionType.GreaterThan, (config) => new GreaterThanCondition(config));
    cf.register<LessThanConditionConfig>
        (ConditionType.LessThan, (config) => new LessThanCondition(config));
    cf.register<GreaterThanOrEqualConditionConfig>
        (ConditionType.GreaterThanOrEqual, (config) => new GreaterThanOrEqualCondition(config));
    cf.register<LessThanOrEqualConditionConfig>
        (ConditionType.LessThanOrEqual, (config) => new LessThanOrEqualCondition(config));
    cf.register<EqualToValueConditionConfig>(
        ConditionType.EqualToValue, (config) => new EqualToValueCondition(config));
    cf.register<NotEqualToValueConditionConfig>
        (ConditionType.NotEqualToValue, (config) => new NotEqualToValueCondition(config));
    cf.register<GreaterThanValueConditionConfig>
        (ConditionType.GreaterThanValue, (config) => new GreaterThanValueCondition(config));
    cf.register<LessThanValueConditionConfig>
        (ConditionType.LessThanValue, (config) => new LessThanValueCondition(config));
    cf.register<GreaterThanOrEqualValueConditionConfig>
        (ConditionType.GreaterThanOrEqualValue, (config) => new GreaterThanOrEqualValueCondition(config));
    cf.register<LessThanOrEqualValueConditionConfig>
        (ConditionType.LessThanOrEqualValue, (config) => new LessThanOrEqualValueCondition(config));    
    
    cf.register<StringLengthConditionConfig>
        (ConditionType.StringLength, (config) => new StringLengthCondition(config));
    cf.register<AllMatchConditionConfig>
        (ConditionType.And, (config) => new AllMatchCondition(config));
    cf.register<AnyMatchConditionConfig>
        (ConditionType.Or, (config) => new AnyMatchCondition(config));
    cf.register<AllMatchConditionConfig>
        (ConditionType.All, (config) => new AllMatchCondition(config));
    cf.register<AnyMatchConditionConfig>
        (ConditionType.Any, (config) => new AnyMatchCondition(config));
    cf.register<CountMatchesConditionConfig>
        (ConditionType.CountMatches, (config) => new CountMatchesCondition(config));
    cf.register<NotNullConditionConfig>(
        ConditionType.NotNull, (config) => new NotNullCondition(config));
    cf.register<PositiveConditionConfig>
        (ConditionType.Positive, (config) => new PositiveCondition(config));  
    cf.register<IntegerConditionConfig>
        (ConditionType.Integer, (config) => new IntegerCondition(config));
    cf.register<MaxDecimalsConditionConfig>
        (ConditionType.MaxDecimals, (config) => new MaxDecimalsCondition(config));
    cf.register<NotConditionConfig>
        (ConditionType.Not, (config) => new NotCondition(config));
    cf.register<WhenConditionConfig>
        (ConditionType.When, (config) => new WhenCondition(config));

}


/**
 * Provides a default set of cultures for testing: en, en-US, es, es-MX, fr.
 */
export function registerCultures(cs: ICultureService): void
{
    let cultures: Array<CultureIdFallback> = [
            {
                cultureId: 'en',
                fallbackCultureId: null    // when this is the default culture,
            },
            {
                cultureId: 'en-US',
                fallbackCultureId: 'en'
            },
            {
                cultureId: 'es',
                fallbackCultureId: 'en'
            },
            {
                cultureId: 'es-MX',
                fallbackCultureId: 'es'
            },
            {
                cultureId: 'fr',
                fallbackCultureId: 'en'
            }
    ];
    cultures.forEach((culture) => cs.register(culture));
}

/**
 * Adds all built-in formatters to the DataTypeFormatterService.
 * @param dtfs 
 */
export function registerDataTypeFormatters(dtfs: DataTypeFormatterService): void
{
    dtfs.register(new StringFormatter());
    dtfs.register(new NumberFormatter());     // options?: Intl.NumberFormatOptions
    dtfs.register(new IntegerFormatter());    // options?: Intl.NumberFormatOptions
    dtfs.register(new DateFormatter());       // options?: Intl.DateTimeFormatOptions
    dtfs.register(new CapitalizeStringFormatter());
    dtfs.register(new UppercaseStringFormatter());
    dtfs.register(new LowercaseStringFormatter());
    dtfs.register(new DateTimeFormatter());       // options?: Intl.DateTimeFormatOptions
    dtfs.register(new AbbrevDateFormatter());     // options?: Intl.DateTimeFormatOptions
    dtfs.register(new AbbrevDOWDateFormatter());  // options?: Intl.DateTimeFormatOptions
    dtfs.register(new LongDateFormatter());       // options?: Intl.DateTimeFormatOptions
    dtfs.register(new LongDOWDateFormatter());    // options?: Intl.DateTimeFormatOptions
    dtfs.register(new TimeofDayFormatter());      // options?: Intl.DateTimeFormatOptions
    dtfs.register(new TimeofDayHMSFormatter());   // options?: Intl.DateTimeFormatOptions
    dtfs.register(new CurrencyFormatter('USD'));  // set this to your currency code
    // defaultCurrencyCode: 'USD', options?: Intl.NumberFormatOptions, cultureToCurrencyCode? { 'en-US' : 'USD', 'es-SP': 'EUR' }

    dtfs.register(new PercentageFormatter());     // options?: Intl.NumberFormatOptions
    dtfs.register(new Percentage100Formatter());  // options?: Intl.NumberFormatOptions
    // NOTE: BooleanFormatter has its strings localized in ValidationServices.TextLocalizerService
    // connected to the TrueLabell10n and FalseLabell10n properties.
    dtfs.register(new BooleanFormatter(LookupKey.Boolean)); // "true" and "false"
   // Example of providing another set of labels for true/false by supplying a different lookup key
    dtfs.register(new BooleanFormatter(LookupKey.YesNoBoolean, 'yes', 'no'));     
}

/**
 * Adds all built-in DataTypeConverters to the DataTypeConverterService.
 * @param dtcs 
 */
export function registerDataTypeConverters(dtcs: DataTypeConverterService): void
{
    dtcs.register(new DateTimeConverter());         // Source = Date object, result = LookupKey.DateTime
    dtcs.register(new LocalDateOnlyConverter());    // Source = Date object, result = LookupKey.LocalDate
    dtcs.register(new TimeOfDayOnlyConverter());    // Source = Date object, result = LookupKey.TimeOfDay
    dtcs.register(new TimeOfDayHMSOnlyConverter()); // Source = Date object, result = LookupKey.TimeOfDayHMS

    // this takes any call where no LookupKey was supplied, in addition to LookupKey.Date.
    // As a result, it is placed after converters that are more specific.
    dtcs.register(new UTCDateOnlyConverter());      // Source = Date object, result = LookupKey.Date or no LookupKey

    // see \examples\ folder for numerous examples of custom DataTypeConverters.
    dtcs.register(new CaseInsensitiveStringConverter());    // Source = string, result = LookupKey.CaseInsensitive
    dtcs.register(new IntegerConverter());                  // Source = number, result = LookupKey.Integer
    dtcs.register(new NumericStringToNumberConverter());    // Source = string, result = LookupKey.Number or LookupKey.Integer

}

/**
 * Adds the CleanUpStringParser and NumberParser for en and en-US to the DataTypeParserService.
 * @param dtps 
 */
export function registerDataTypeParsers(dtps: IDataTypeParserService): void {

    // minimal support. Just handling String and Number lookup keys.
    // string trimming
    dtps.register(new CleanUpStringParser(LookupKey.String, { trim: true }));
    
    // any number in US format
    dtps.register(new NumberParser(['en', 'en-US'], {
        decimalSeparator: '.',
        negativeSymbol: '-'
    }));
}
