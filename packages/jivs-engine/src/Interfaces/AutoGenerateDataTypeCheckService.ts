/**
 * {@inheritDoc Services/Types/IAutoGenerateDataTypeCheckService!IAutoGenerateDataTypeCheckService:interface }
 * @module Services/Types/IAutoGenerateDataTypeCheckService
 */

import { ICondition } from "./Conditions";
import { IDataTypeCheckGenerator } from "./DataTypeCheckGenerator";
import { IDataTypeService } from "./DataTypes";
import { IInputValueHost } from "./InputValueHost";
import { IServicesAccessor } from "./Services";

/**
 * Service that supports automatic generation of Conditions for the Data Type Check
 * using {@link DataTypes/Types/IDataTypeCheckGenerator!IDataTypeCheckGenerator | IDataTypeCheckGenerator} instances.
 * This feature is specific to InputValueHosts as it utilizes both the Input Value and Native Value.
 */
export interface IAutoGenerateDataTypeCheckService extends
    IDataTypeService<IDataTypeCheckGenerator>, IServicesAccessor {
    
    /**
     * When true, data type check conditions are auto generated if not 
     * supplied in the ValueHost's list of validators.
     * Defaults to true.
     */
    enabled: boolean;
    
    /**
     * Works together with IDataTypeCheckGenerator to attempt to supply one or more 
     * Conditions suitable for the given data type lookup key that is used as a Data Type Check
     * against the native value.
     * 
     * By default, automatic generation uses the DataTypeCheckCondition. If you implement
     * an IDataTypeCheckGenerator class, you may return multiple conditions. In that case, 
     * return a DataTypeCheckCondition too if it is needed.
     * 
     * That condition determines an error when InputValueHost.getValue() returns undefined,
     * which is a result of a conversion of InputValue fails.
     * 
     * There are other ways to check a data type. Strings with a well 
     * defined pattern will often be the same as they were between
     * Input Value and Native Value, aside from trimming spaces.
     * So the NativeValue is a string that will need to be checked against
     * a regular expression or some other rule that confirms the string matches requirements.
     * 
     * Thats when you create a IDataTypeCheckGenerator class and register it with
     * autoGenerateDataTypeCheckService.
     * 
     * @param dataTypeLookupKey 
     * @param valueHost
     * @returns The list of Conditions generated by a matching IDataTypeCheckGenerator,
     * or a DataTypeCheckCondition if no IDataTypeCheckGenerator was found. If DataTypeCheckGenerator
     * returns an empty array, it means do not generate the DataTypeCheckCondition and this function
     * returns the empty array itself.
     */
    autoGenerateDataTypeConditions(valueHost: IInputValueHost, dataTypeLookupKey: string): Array<ICondition>;

    /**
     * Finds the first {@link DataTypes/Types/IDataTypeCheckGenerator!IDataTypeCheckGenerator | IDataTypeCheckGenerator}
     * that supports the value, or null if none are found.
     * @param dataTypeLookupKey 
     * @returns 
     */
    find(dataTypeLookupKey: string): IDataTypeCheckGenerator | null; 
}


