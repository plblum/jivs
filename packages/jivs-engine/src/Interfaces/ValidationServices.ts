/**
 * Provides a dependency injection approach to this library.
 * @module Services/Types/ValidationServices
 */

import { IConditionFactory } from './Conditions';
import { IAutoGenerateDataTypeCheckService } from './AutoGenerateDataTypeCheckService';
import { IDataTypeComparerService } from './DataTypeComparerService';
import { IDataTypeConverterService } from './DataTypeConverterService';
import { IDataTypeFormatterService } from './DataTypeFormatterService';
import { IDataTypeIdentifierService } from './DataTypeIdentifierService';
import { IInputValidatorFactory } from './InputValidator';
import { ILoggerService } from './LoggerService';
import { ITextLocalizerService } from './TextLocalizerService';
import { IValueHostFactory } from './ValueHost';
import { IMessageTokenResolverService } from './MessageTokenResolverService';

/**
 * Interface to have access to services.
 */
export interface IServicesAccessor
{
/**
 * Provides access to services.
 */
    services: IValidationServices;    
}

/**
 * Basic services framework
 */
export interface IServices
{
    /**
     * Returns the service by its name identifier.
     * Returns null if the name identifier is unregistered.
     * @param serviceName - Will be a case insensitive match
     */
    getService<T>(serviceName: string): T | null;

    /**
     * Adds or replaces a service.
     * @param serviceName - name that identifies this service and
     * will be used in getService().
     * @param service - the service. It can be a class, object, or primitive.
     * Will be a case insensitive match
     */
    setService(serviceName: string, service: any): void;
}

/**
 * Full interface representation of ValidationServices.
 */
export interface IValidationServices extends IServices {
/**
 * The culture shown to the user in the app. Its the ISO language-region format.
   This value is the starting point to search through localizations.
 */    
    activeCultureId: string;

    /**
     * Service to get the ILogger instance that replaces
     * tokens in messages.
     * Defaults to using the global defaultLoggerService
     */
    loggerService: ILoggerService;    
    /**
     * Factory to create Condition objects.
     */
    conditionFactory: IConditionFactory;

    /**
     * Service for formatting data types used within tokens of error messages
    *  using {@link DataTypes/Types/IDataTypeFormatter!IDataTypeFormatter | IDataTypeFormatter} instances.
     */
    dataTypeFormatterService: IDataTypeFormatterService;
    
    /**
     * Service for identifing the Data Type Lookup Key associated with a data type
     * using {@link DataTypes/Types/IDataTypeIdentifier!IDataTypeIdentifier | IDataTypeIdentifier} instances.
     */
    dataTypeIdentifierService: IDataTypeIdentifierService;
    
    /**
     * Service for changing the original value into 
     * something that you want a condition to evaluate
     * using {@link DataTypes/Types/IDataTypeConverter!IDataTypeConverter | IDataTypeConverter} instances.
     */
    dataTypeConverterService: IDataTypeConverterService;
    
    /**
     * Service for changing the comparing two values
     * using {@link DataTypes/Types/IDataTypeComparer!IDataTypeComparer | IDataTypeComparer} instances.
     */
    dataTypeComparerService: IDataTypeComparerService;
    
    /**
     * Service that supports automatic generation of Conditions for the Data Type Check
     * using {@link DataTypes/Types/IDataTypeCheckGenerator!IDataTypeCheckGenerator | IDataTypeCheckGenerator} instances.
     */
    autoGenerateDataTypeCheckService: IAutoGenerateDataTypeCheckService;

    /**
     * Service to text localization specific, effectively mapping
     * a text key to a language specific version of that text.
     * Error messages and IDataTypeFormatters use this.
     */
    textLocalizerService: ITextLocalizerService;

    /**
     * Service to get the IMessageTokenResolver instance that replaces
     * tokens in messages.
     */
    messageTokenResolverService: IMessageTokenResolverService;

    /**
     * Factory for generating classes that implement IValueHost that use ValueHostDescriptor.
     */
    valueHostFactory: IValueHostFactory;

    /**
     * Factory for generating InputValidator.
     */
    inputValidatorFactory: IInputValidatorFactory;

}

/**
 * Determines if the source implements IServicesAccessor, and returns it typecasted.
 * If not, it returns null.
 * @param source 
 */
export function toIServicesAccessor(source: any): IServicesAccessor | null {
    if (source && typeof source === 'object') {
        let test = source as IServicesAccessor;       
        if ('services' in test)
            return test;
    }
    return null;
}

/**
 * Names for services supported by IValidationServices.getService.
 * Users can add other services to IValidationService simply by providing
 * a unique name. It doesn't have to be in this type.
 */
export enum ServiceName {
    /**
     * IDataTypeFormatterService
     */
    formatter = 'Formatter',
    /**
     * IDataTypeConverterService
     */    
    converter = 'Converter',
    /**
     * IDataTypeComparerService
     */    
    comparer = 'Comparer',
    /**
     * IDataTypeIdentifierService
     */    
    identifier = 'Identifier',
    /**
     * IAutoGenerateDataTypeCheckService
     */    
    autoGenerator = 'AutoGenerator',
    /**
     * ILoggerService
     */    
    logger = 'Logger',
    /**
     * IConditionsFactory
     */    
    conditionFactory = 'ConditionFactory',
    /**
     * ITextLocalizerService
     */
    textLocalizer = 'TextLocalizer',
     /**
     * IMessageTokenResolver
     */
    messageTokenResolver = 'MessageTokenResolver',
    /**
     * IValueHostFactory
     */
    valueHostFactory = 'ValueHostFactory',
    /**
     * IInputValidatorFactory
     */
    inputValidatorFactory = 'InputValidatorFactory',
    /**
     * IModelToValueHostFactory - in jivs-model
     */
    modelToValueHostFactory = 'ModelToValueHostFactory',
    /**
     * IValueHostToModelFactory - in jivs-ssot
     */
    valueHostToModelFactory = 'ValueHostToModelFactory',
    /**
     * IDataTypeParserService - in jivs-parsers
     */
    parsers = 'Parsers'
}