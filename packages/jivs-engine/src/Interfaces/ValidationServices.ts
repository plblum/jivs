/**
 * Provides a dependency injection approach to this library.
 * @module Services/Types/IValidationServices
 */

import { IConditionFactory } from './Conditions';
import { IAutoGenerateDataTypeCheckService } from './AutoGenerateDataTypeCheckService';
import { IDataTypeComparerService } from './DataTypeComparerService';
import { IDataTypeConverterService } from './DataTypeConverterService';
import { IDataTypeFormatterService } from './DataTypeFormatterService';
import { IDataTypeIdentifierService } from './DataTypeIdentifierService';
import { IValidatorFactory } from './Validator';
import { ILoggerService } from './LoggerService';
import { ITextLocalizerService } from './TextLocalizerService';
import { IValueHostFactory } from './ValueHost';
import { IMessageTokenResolverService } from './MessageTokenResolverService';
import { ICultureService } from './CultureService';
import { ILookupKeyFallbackService } from './LookupKeyFallbackService';

/**
 * Base interface for all services including factories
 */
export interface IService
{
    serviceName: string;
}


/**
 * Interface to have access to services.
 */
export interface IServicesAccessor
{
/**
 * Provides access to services.
 */
    services: IValidationServices;    
}

/**
 * A service that has a reference back to the IServices object.
 */
export interface IServiceWithAccessor extends IService, IServicesAccessor
{
    
}

/**
 * Basic services framework
 */
export interface IServices
{
    /**
     * Returns the service by its name identifier.
     * Returns null if the name identifier is unregistered.
     * @param serviceName - Will be a case insensitive match
     */
    getService<T>(serviceName: string): T | null;

    /**
     * Adds or replaces a service.
     * @param serviceName - name that identifies this service and
     * will be used in getService().
     * @param service - the service. It can be a class, object, or primitive.
     * Will be a case insensitive match
     */
    setService(serviceName: string, service: any): void;
}

/**
 * Full interface representation of ValidationServices.
 */
export interface IValidationServices extends IServices {

    /**
     * Service for identifying cultures that you will use in the app,
     * by their CultureID  ('en', 'en-US', 'en-GB', etc), and provides
     * fallbacks for when a requested CultureID is not found.
     */
    cultureService: ICultureService;

    /**
     * Service to get the ILogger instance that replaces
     * tokens in messages.
     * Defaults to using the global defaultLoggerService
     */
    loggerService: ILoggerService;    
    /**
     * Factory to create Condition objects.
     */
    conditionFactory: IConditionFactory;

    /**
     * Service for formatting data types used within tokens of error messages
    *  using {@link DataTypes/Types/IDataTypeFormatter!IDataTypeFormatter | IDataTypeFormatter} instances.
     */
    dataTypeFormatterService: IDataTypeFormatterService;
    
    /**
     * Service for identifing the Data Type Lookup Key associated with a data type
     * using {@link DataTypes/Types/IDataTypeIdentifier!IDataTypeIdentifier | IDataTypeIdentifier} instances.
     */
    dataTypeIdentifierService: IDataTypeIdentifierService;
    
    /**
     * Service for changing the original value into 
     * something that you want a condition to evaluate
     * using {@link DataTypes/Types/IDataTypeConverter!IDataTypeConverter | IDataTypeConverter} instances.
     */
    dataTypeConverterService: IDataTypeConverterService;
    
    /**
     * Service for changing the comparing two values
     * using {@link DataTypes/Types/IDataTypeComparer!IDataTypeComparer | IDataTypeComparer} instances.
     */
    dataTypeComparerService: IDataTypeComparerService;
    
    /**
     * Service that supports automatic generation of Conditions for the Data Type Check
     * using {@link DataTypes/Types/IDataTypeCheckGenerator!IDataTypeCheckGenerator | IDataTypeCheckGenerator} instances.
     */
    autoGenerateDataTypeCheckService: IAutoGenerateDataTypeCheckService;

    /**
     * Service for creating a relationship between a lookup key and another
     * that is the base data type it is built around.
     * For example, LookupKey.Integer uses a number as the base data type.
     * So it has a relationship with LookupKey.Number.
     * This service keeps these relationships. The DataTypeFormatterService and DataTypeParserService
     * consume this as they try to find the best fitting Formatter or Parser.
     * So go ahead and assign your ValueHost.datatype to LookupKey.Integer.
     * If there is no IntegerParser (there isn't), expect to be using the NumberParser.
     */
    lookupKeyFallbackService: ILookupKeyFallbackService;

    /**
     * Service to text localization specific, effectively mapping
     * a text key to a language specific version of that text.
     * Error messages and IDataTypeFormatters use this.
     */
    textLocalizerService: ITextLocalizerService;

    /**
     * Service to get the IMessageTokenResolver instance that replaces
     * tokens in messages.
     */
    messageTokenResolverService: IMessageTokenResolverService;

    /**
     * Factory for generating classes that implement IValueHost that use ValueHostConfig.
     */
    valueHostFactory: IValueHostFactory;

    /**
     * Factory for generating Validator.
     */
    validatorFactory: IValidatorFactory;

}

/**
 * Determines if the source implements IServicesAccessor, and returns it typecasted.
 * If not, it returns null.
 * @param source 
 */
export function toIServicesAccessor(source: any): IServicesAccessor | null {
    if (source && typeof source === 'object') {
        let test = source as IServicesAccessor;       
        if ('services' in test)
            return test;
    }
    return null;
}

/**
 * Names for services supported by IValidationServices.getService.
 * Users can add other services to IValidationService simply by providing
 * a unique name. It doesn't have to be in this type.
 */
export enum ServiceName {
    /**
     * IDataTypeFormatterService
     */
    formatter = 'Formatter',
    /**
     * IDataTypeConverterService
     */    
    converter = 'Converter',
    /**
     * IDataTypeComparerService
     */    
    comparer = 'Comparer',
    /**
     * IDataTypeIdentifierService
     */    
    identifier = 'Identifier',
    /**
     * IAutoGenerateDataTypeCheckService
     */    
    autoGenerator = 'AutoGenerator',

    /**
     * ICultureService
     */
    culture = 'Culture',
    /**
     * ILoggerService
     */    
    logger = 'Logger',
    /**
     * IConditionsFactory
     */    
    conditionFactory = 'ConditionFactory',

    /**
     * ILookupKeyFallbackService
     */
    lookupKeyFallback = 'LookupKeyFallback',
    /**
     * ITextLocalizerService
     */
    textLocalizer = 'TextLocalizer',
     /**
     * IMessageTokenResolver
     */
    messageTokenResolver = 'MessageTokenResolver',
    /**
     * IValueHostFactory
     */
    valueHostFactory = 'ValueHostFactory',
    /**
     * IValidatorFactory
     */
    validatorFactory = 'ValidatorFactory',
    /**
     * IModelToValuesFactory - in jivs-model
     */
    modelToValuesFactory = 'ModelToValuesFactory',
    /**
     * IValuesToModelFactory - in jivs-ssot
     */
    valuesToModelFactory = 'ValuesToModelFactory',
    /**
     * IDataTypeParserService - in jivs-parsers
     */
    parsers = 'Parsers'
}

/**
 * Assign to services that support a fallback version of itself,
 * so the user can override the service with a special case,
 * and the fallback handles the rest.
 */
export interface IServiceWithFallback<T> extends IService
{
    /**
     * Reference to a fallback of the same service or null if no fallback.
     */
    fallbackService: T | null;
}
/**
 * Determines if the source implements IServiceWithFallback, and returns it typecasted.
 * If not, it returns null.
 * @param source 
 */
export function toIServiceWithFallback(source: any): IServiceWithFallback<any> | null {
    if (source && typeof source === 'object') {
        let test = source as IServiceWithFallback<any>;       
        if ('fallbackService' in test)
            return test;
    }
    return null;
}
