/**
 * Provides a dependency injection approach to this library.
 * @module Services/Types/ValidationServices
 */

import { IConditionFactory } from './Conditions';
import { IAutoGenerateDataTypeCheckService } from './AutoGenerateDataTypeCheckService';
import { IDataTypeComparerService } from './DataTypeComparerService';
import { IDataTypeConverterService } from './DataTypeConverterService';
import { IDataTypeFormatterService } from './DataTypeFormatterService';
import { IDataTypeIdentifierService } from './DataTypeIdentifierService';
import { IInputValidatorFactory } from './InputValidator';
import { ILoggerService } from './LoggerService';
import { ITextLocalizerService } from './TextLocalizerService';
import { IValueHostFactory } from './ValueHost';
import { IMessageTokenResolverService } from './MessageTokenResolverService';

/**
 * Interface to have access to services.
 */
export interface IServicesAccessor
{
/**
 * Provides access to services.
 */
    services: IValidationServices;    
}

/**
 * Subset of the IValidationServices interface designed to limit
 * exposure where consumers need only its features.
 * Helps for mocking and testing.
 */
export interface IBasicValidationServices {
    /**
     * Service to get the ILogger instance that replaces
     * tokens in messages.
     * Defaults to using the global defaultLoggerService
     */
    loggerService: ILoggerService;
}


/**
 * Full interface representation of ValidationServices.
 */
export interface IValidationServices extends IBasicValidationServices {
/**
 * The culture shown to the user in the app. Its the ISO language-region format.
   This value is the starting point to search through localizations.
 */    
    activeCultureId: string;

    /**
     * Factory to create Condition objects.
     */
    conditionFactory: IConditionFactory;

    /**
     * Service for formatting data types used within tokens of error messages
    *  using {@link DataTypes/Types/IDataTypeFormatter!IDataTypeFormatter | IDataTypeFormatter} instances.
     */
    dataTypeFormatterService: IDataTypeFormatterService;
    
    /**
     * Service for identifing the Data Type Lookup Key associated with a data type
     * using {@link DataTypes/Types/IDataTypeIdentifier!IDataTypeIdentifier | IDataTypeIdentifier} instances.
     */
    dataTypeIdentifierService: IDataTypeIdentifierService;
    
    /**
     * Service for changing the original value into 
     * something that you want a condition to evaluate
     * using {@link DataTypes/Types/IDataTypeConverter!IDataTypeConverter | IDataTypeConverter} instances.
     */
    dataTypeConverterService: IDataTypeConverterService;
    
    /**
     * Service for changing the comparing two values
     * using {@link DataTypes/Types/IDataTypeComparer!IDataTypeComparer | IDataTypeComparer} instances.
     */
    dataTypeComparerService: IDataTypeComparerService;
    
    /**
     * Service that supports automatic generation of Conditions for the Data Type Check
     * using {@link DataTypes/Types/IDataTypeCheckGenerator!IDataTypeCheckGenerator | IDataTypeCheckGenerator} instances.
     */
    autoGenerateDataTypeCheckService: IAutoGenerateDataTypeCheckService;

    /**
     * Service to text localization specific, effectively mapping
     * a text key to a language specific version of that text.
     * Error messages and IDataTypeFormatters use this.
     */
    textLocalizerService: ITextLocalizerService;

    /**
     * Service to get the IMessageTokenResolver instance that replaces
     * tokens in messages.
     */
    messageTokenResolverService: IMessageTokenResolverService;

    /**
     * Factory for generating classes that implement IValueHost that use ValueHostDescriptor.
     */
    valueHostFactory: IValueHostFactory;

    /**
     * Factory for generating InputValidator.
     */
    inputValidatorFactory: IInputValidatorFactory;

}

/**
 * Determines if the source implements IServicesAccessor, and returns it typecasted.
 * If not, it returns null.
 * @param source 
 */
export function toIServicesAccessor(source: any): IServicesAccessor | null {
    if (source && typeof source === 'object') {
        let test = source as IServicesAccessor;       
        if ('services' in test)
            return test;
    }
    return null;
}