/**
 * Supplies services and tools to be used as dependency injection
 * into the classes of this system.
 * There are many configuration choices involved. Its best to have
 * a function that creates a ValidationService with its configuration together.
 * Copy the /starter_code/create_services.ts file into your app.
 * It contains such a function, createValidationServices().
 * Edit that file to adjust your configuration.
 * @module Services/ConcreteClasses/ValidationServices
 */

import { CodingError } from '../Utilities/ErrorHandling';
import type { IValidatorFactory } from '../Interfaces/Validator';
import { ServiceName, type IValidationServices } from '../Interfaces/ValidationServices';
import { ValidatorFactory } from '../Validation/Validator';
import { IAutoGenerateDataTypeCheckService } from '../Interfaces/AutoGenerateDataTypeCheckService';
import { IDataTypeFormatterService } from '../Interfaces/DataTypeFormatterService';
import { IMessageTokenResolverService } from '../Interfaces/MessageTokenResolverService';
import { ValueHostsServices } from './ValueHostsServices';
import { IDataTypeParserService } from '../Interfaces/DataTypeParserService';
import { IValidatorConfigMergeService } from '../Interfaces/ConfigMergeService';
import { ValidationManagerConfigAnalysisService } from './ConfigAnalysisService/ConfigAnalysisService';
import { IConfigAnalysisService } from '../Interfaces/ConfigAnalysisService';

/**
 * Supplies services and tools to be used as dependency injection
 * into the classes of this system. It also supplies factories.
 * There are many configuration choices involved. Its best to have
 * a function that creates a ValidationService with its configuration together.
 * Copy the /starter_code/create_services.ts file into your app.
 * It contains such a function, createValidationServices().
 * Edit that file to adjust your configuration.
 */
export class ValidationServices extends ValueHostsServices implements IValidationServices {

    /**
     * Service for formatting data types used within tokens of error messages
    *  using {@link DataTypes/Types/IDataTypeFormatter!IDataTypeFormatter | IDataTypeFormatter} instances.
     */
    public get dataTypeFormatterService(): IDataTypeFormatterService {
        let service = this.getService<IDataTypeFormatterService>(ServiceName.formatter);
        if (!service)
            throw new CodingError('Must assign ValidationServices.dataTypeFormatterService.');

        return service;
    }
    public set dataTypeFormatterService(service: IDataTypeFormatterService) {
        this.setService(ServiceName.formatter, service);
    }
    /**
     * Service for formatting data types used within tokens of error messages
    *  using {@link DataTypes/Types/IDataTypeParser!IDataTypeParser | IDataTypeParser} instances.
     */
    public get dataTypeParserService(): IDataTypeParserService {
        let service = this.getService<IDataTypeParserService>(ServiceName.parser);
        if (!service)
            throw new CodingError('Must assign ValidationServices.dataTypeParserService.');

        return service;
    }
    public set dataTypeParserService(service: IDataTypeParserService) {
        this.setService(ServiceName.parser, service);
    }

    /**
     * Service that supports automatic generation of Conditions for the Data Type Check
     * using {@link DataTypes/Types/IDataTypeCheckGenerator!IDataTypeCheckGenerator | IDataTypeCheckGenerator} instances.
     */
    public get autoGenerateDataTypeCheckService(): IAutoGenerateDataTypeCheckService {
        let service = this.getService<IAutoGenerateDataTypeCheckService>(ServiceName.autoGenerator);
        if (!service)
            throw new CodingError('Must assign ValidationServices.autoGenerateDataTypeCheckService.');

        return service;
    }
    public set autoGenerateDataTypeCheckService(service: IAutoGenerateDataTypeCheckService) {
        this.setService(ServiceName.autoGenerator, service);
    }

    /**
     * Service to get the IMessageTokenResolver instance that replaces
     * tokens in messages.
     */
    public get messageTokenResolverService(): IMessageTokenResolverService {
        let service = this.getService<IMessageTokenResolverService>(ServiceName.messageTokenResolver);
        if (!service)
            throw new CodingError('Must assign ValidationServices.MessageTokenResolverService.');

        return service;
    }
    public set messageTokenResolverService(service: IMessageTokenResolverService) {
        this.setService(ServiceName.messageTokenResolver, service);
    }

    /**
     * Service to get the IValidatorConfigMergeService instance that 
     * determines how to merge ValueHost configurations from business logic and UI.
     */
    public get validatorConfigMergeService(): IValidatorConfigMergeService {
        let service = this.getService<IValidatorConfigMergeService>(ServiceName.validatorConfigMerge);
        if (!service)
            throw new CodingError('Must assign ValidationServices.validatorConfigMergeService.');

        return service;
    }
    public set validatorConfigMergeService(service: IValidatorConfigMergeService) {
        this.setService(ServiceName.validatorConfigMerge, service);
    }        

    //#region ValidatorFactory    
    /**
     * The ValidatorFactory to use.
     * It supplies a default if not setup by the user.
     */
    public get validatorFactory(): IValidatorFactory {
        let service = this.getService<IValidatorFactory>(ServiceName.validatorFactory);
        if (!service) {
            service = new ValidatorFactory();
            this.setService(ServiceName.validatorFactory, service);
        }
        return service;
    }
    public set validatorFactory(factory: ValidatorFactory) {
        this.setService(ServiceName.validatorFactory, factory);
    }

    //#endregion ValidatorFactory     
    protected defaultConfigAnalysisService(): IConfigAnalysisService {
        return new ValidationManagerConfigAnalysisService();
    }    
}
