import { ConditionFactory } from "../src/Conditions/ConditionFactory";
import { type ILoggerService, LoggingLevel } from "../src/Interfaces/LoggerService";
import type { IValidationServices } from "../src/Interfaces/ValidationServices";
import type { IValueHost, SetValueOptions, ValueHostState, IValueHostFactory, ValueHostDescriptor, ValueChangedHandler, ValueHostStateChangedHandler } from "../src/Interfaces/ValueHost";
import { IValueHostResolver, IValueHostsManager } from "../src/Interfaces/ValueHostResolver";
import { ConditionBase } from "../src/Conditions/ConditionBase";
import { ConditionDescriptor, ConditionEvaluateResult, ConditionCategory, IConditionFactory } from "../src/Interfaces/Conditions";
import { IInputValueHost, InputValueChangedHandler, InputValueHostState, ValueHostValidatedHandler } from "../src/Interfaces/InputValueHost";
import { ValidateOptions, ValidateResult, ValidationResult, BusinessLogicError, IssueFound, IssueSnapshot } from "../src/Interfaces/Validation";
import { IInputValidator, IInputValidatorFactory, InputValidatorDescriptor } from "../src/Interfaces/InputValidator";
import { IValidationManager, IValidationManagerCallbacks, ValidationManagerStateChangedHandler, ValidationManagerValidatedHandler } from "../src/Interfaces/ValidationManager";
import { ITextLocalizerService } from "../src/Interfaces/TextLocalizerService";
import { IDataTypeFormatterService } from "../src/Interfaces/DataTypeFormatterService";
import { IAutoGenerateDataTypeCheckService } from "../src/Interfaces/AutoGenerateDataTypeCheckService";
import { IDataTypeComparerService } from "../src/Interfaces/DataTypeComparerService";
import { IDataTypeConverterService } from "../src/Interfaces/DataTypeConverterService";
import { IDataTypeIdentifierService } from "../src/Interfaces/DataTypeIdentifierService";
import { IMessageTokenResolverService } from "../src/Interfaces/MessageTokenResolverService";
export declare function createMockValidationManagerForMessageTokenResolver(registerLookupKeys?: boolean): IValidationManager;
export declare class MockValueHost implements IValueHost {
    constructor(valueHostsManager: IValueHostsManager, id: string, dataTypeLookupKey: string, label?: string);
    _valueHostsManager: IValueHostsManager;
    _id: string;
    _label: string;
    _value: any;
    _dataTypeLookupKey: string;
    get valueHostsManager(): IValueHostsManager;
    getId(): string;
    getLabel(): string;
    getValue(): any;
    setValue(value: any, options?: SetValueOptions | undefined): void;
    setValueToUndefined(options?: SetValueOptions | undefined): void;
    getDataType(): string | null;
    saveIntoState(key: string, value: any): void;
    getFromState(key: string): any | undefined;
    _savedItems: {
        [key: string]: any;
    };
    isChanged: boolean;
    setLabel(label: string | null | undefined, labell10n?: string | null | undefined): void;
}
export declare class MockInputValueHost extends MockValueHost implements IInputValueHost {
    _inputValue: any;
    _conversionErrorMessage: string | undefined;
    setValue(value: any, options?: SetValueOptions | undefined): void;
    getInputValue(): any;
    setInputValue(value: any, options?: SetValueOptions | undefined): void;
    setValues(nativeValue: any, inputValue: any, options?: SetValueOptions | undefined): void;
    validate(options?: ValidateOptions): ValidateResult;
    clearValidation(): void;
    isValid: boolean;
    doNotSaveNativeValue(): boolean;
    validationResult: ValidationResult;
    setBusinessLogicError(error: BusinessLogicError): void;
    clearBusinessLogicErrors(): void;
    getIssuesFound(): Array<IssueFound> | null;
    getIssuesForInput(): IssueSnapshot[];
    getIssuesForSummary(group?: string | undefined): IssueSnapshot[];
    getConversionErrorMessage(): string | null;
    requiresInput: boolean;
    otherValueHostChangedNotification(valueHostIdThatChanged: string, revalidate: boolean): void;
    getValidator(conditionType: string): IInputValidator | null;
    addValidator(descriptor: InputValidatorDescriptor): void;
    setGroup(group: string): void;
    changeEnabledOnValidator(conditionType: string, enabled: boolean): void;
}
/**
 * Flexible Mock ValidationServices with MockCapturingLogger.
 * Optionally populated with standard Conditions and data types.
 */
export declare class MockValidationServices implements IValidationServices {
    constructor(registerStandardConditions: boolean, registerStandardDataTypes: boolean);
    get activeCultureId(): string;
    set activeCultureId(cultureID: string);
    private _activeCultureID;
    get conditionFactory(): IConditionFactory;
    private _conditionFactory;
    get dataTypeFormatterService(): IDataTypeFormatterService;
    set dataTypeFormatterService(service: IDataTypeFormatterService);
    private _dataTypeFormatterService;
    get dataTypeIdentifierService(): IDataTypeIdentifierService;
    set dataTypeIdentifierService(service: IDataTypeIdentifierService);
    private _dataTypeIdentifierService;
    get dataTypeConverterService(): IDataTypeConverterService;
    set dataTypeConverterService(service: IDataTypeConverterService);
    private _dataTypeConverterService;
    get dataTypeComparerService(): IDataTypeComparerService;
    set dataTypeComparerService(service: IDataTypeComparerService);
    private _dataTypeComparerService;
    get autoGenerateDataTypeCheckService(): IAutoGenerateDataTypeCheckService;
    set autoGenerateDataTypeCheckService(service: IAutoGenerateDataTypeCheckService);
    private _autoGenerateDataTypeCheckService;
    get textLocalizerService(): ITextLocalizerService;
    set textLocalizerService(service: ITextLocalizerService);
    private _textLocalizerService;
    get messageTokenResolverService(): IMessageTokenResolverService;
    private _messageTokenResolverService;
    get loggerService(): ILoggerService;
    private _loggerService;
    get valueHostFactory(): IValueHostFactory;
    set valueHostFactory(factory: IValueHostFactory);
    private _valueHostFactory;
    get inputValidatorFactory(): IInputValidatorFactory;
    set inputValidatorFactory(factory: IInputValidatorFactory);
    private _inputValidatorFactory;
}
/**
 * MockValidationManager limited to implementing support for
 * child ValueHosts.
 */
export declare class MockValidationManager implements IValidationManager, IValidationManagerCallbacks {
    constructor(services: IValidationServices);
    get services(): IValidationServices;
    private _services;
    /**
     * ValueHosts for all ValueHostDescriptors.
     * Always replace a ValueHost when the associated Descriptor or State are changed.
     */
    private _valueHosts;
    addValueHost(id: string, dataTypeLookupKey: string, label: string, value?: any): MockValueHost;
    addInputValueHost(id: string, dataTypeLookupKey: string, label: string, inputValue?: any, nativeValue?: any): MockInputValueHost;
    addInputValueHostWithDescriptor(descriptor: ValueHostDescriptor, state: InputValueHostState | null): IInputValueHost;
    getValueHost(valueHostId: string): IValueHost | null;
    getInputValueHost(valueHostId: string): IInputValueHost | null;
    private _hostStateChanges;
    onValueHostStateChangeHandler: ValueHostStateChangedHandler;
    getHostStateChanges(): Array<ValueHostState>;
    validate(options?: ValidateOptions): Array<ValidateResult>;
    clearValidation(): void;
    isValid: boolean;
    doNotSaveNativeValue(): boolean;
    notifyOtherValueHostsOfValueChange(valueHostIdThatChanged: string, revalidate: boolean): void;
    setBusinessLogicErrors(errors: Array<BusinessLogicError> | null): void;
    getIssuesForInput(valueHostId: string): IssueSnapshot[];
    getIssuesForSummary(group?: string | undefined): IssueSnapshot[];
    get onStateChanged(): ValidationManagerStateChangedHandler | null;
    set onStateChanged(fn: ValidationManagerStateChangedHandler);
    private _onStateChanged;
    get onValidated(): ValidationManagerValidatedHandler | null;
    set onValidated(fn: ValidationManagerValidatedHandler);
    private _onValidated;
    get onValueHostStateChanged(): ValueHostStateChangedHandler | null;
    set onValueHostStateChanged(fn: ValueHostStateChangedHandler);
    private _onValueHostStateChanged;
    get onValueHostValidated(): ValueHostValidatedHandler | null;
    set onValueHostValidated(fn: ValueHostValidatedHandler);
    private _onValueHostValidated;
    get onValueChanged(): ValueChangedHandler | null;
    set onValueChanged(fn: ValueChangedHandler);
    private _onValueChanged;
    get onInputValueChanged(): InputValueChangedHandler | null;
    set onInputValueChanged(fn: InputValueChangedHandler);
    private _onInputValueChanged;
}
export declare class MockCapturingLogger implements ILoggerService {
    minLevel: LoggingLevel;
    captured: Array<MockCapturedLog>;
    log(message: string, level: LoggingLevel, category?: string | undefined, source?: string | undefined): void;
    entryCount(): Number;
    getLatest(): MockCapturedLog | null;
    /**
     * Looks through all captures in order found. If any contain all matching values, it is returned.
     * messageSegment and sourceSegment allow a partial match (case insensitive).
     * Null parameters are not used for searching.
     * @param messageSegment
     */
    findMessage(messageSegment: string | null, logLevel: LoggingLevel | null, category: string | null, sourceSegment: string | null): MockCapturedLog | null;
}
export interface MockCapturedLog {
    message: string;
    level: LoggingLevel;
    category: string | undefined;
    source: string | undefined;
}
export declare const AlwaysMatchesConditionType = "AlwaysMatches";
export declare class AlwaysMatchesCondition extends ConditionBase<ConditionDescriptor> {
    protected get DefaultConditionType(): string;
    evaluate(valueHost: IValueHost | null, valueHostsResolver: IValueHostResolver): ConditionEvaluateResult | Promise<ConditionEvaluateResult>;
    protected get defaultCategory(): ConditionCategory;
    gatherValueHostIds(collection: Set<string>, valueHostsResolver: IValueHostResolver): void;
}
export declare const NeverMatchesConditionType = "NeverMatches";
export declare const NeverMatchesConditionType2 = "NeverMatches2";
export declare class NeverMatchesCondition extends ConditionBase<ConditionDescriptor> {
    protected get DefaultConditionType(): string;
    evaluate(valueHost: IValueHost | null, valueHostsResolver: IValueHostResolver): ConditionEvaluateResult | Promise<ConditionEvaluateResult>;
    protected get defaultCategory(): ConditionCategory;
    gatherValueHostIds(collection: Set<string>, valueHostsResolver: IValueHostResolver): void;
}
export declare const IsUndeterminedConditionType = "AlwaysUndetermined";
export declare class IsUndeterminedCondition extends ConditionBase<ConditionDescriptor> {
    protected get DefaultConditionType(): string;
    evaluate(valueHost: IValueHost | null, valueHostsResolver: IValueHostResolver): ConditionEvaluateResult | Promise<ConditionEvaluateResult>;
    protected get defaultCategory(): ConditionCategory;
    gatherValueHostIds(collection: Set<string>, valueHostsResolver: IValueHostResolver): void;
}
export declare const ThrowsExceptionConditionType = "AlwaysThrows";
export declare class ThrowsExceptionCondition extends ConditionBase<ConditionDescriptor> {
    protected get DefaultConditionType(): string;
    evaluate(valueHost: IValueHost | null, valueHostsResolver: IValueHostResolver): ConditionEvaluateResult | Promise<ConditionEvaluateResult>;
    protected get defaultCategory(): ConditionCategory;
    gatherValueHostIds(collection: Set<string>, valueHostsResolver: IValueHostResolver): void;
}
export declare function registerTestingOnlyConditions(factory: ConditionFactory): void;
