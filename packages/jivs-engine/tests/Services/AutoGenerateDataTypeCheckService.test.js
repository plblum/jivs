import { DataTypeCheckCondition, RegExpCondition } from "../../src/Conditions/ConcreteConditions";
import { ConditionType } from "../../src/Conditions/ConditionTypes";
import { LookupKey } from "../../src/DataTypes/LookupKeys";
import { AutoGenerateDataTypeCheckService } from "../../src/Services/AutoGenerateDataTypeCheckService";
import { MockValidationServices, MockValidationManager } from "../Mocks";
class TestCheckGenerator {
    constructor(dataTypeLookupKey, returns) {
        this.DataTypeLookupKey = dataTypeLookupKey;
        this.Returns = returns;
    }
    supportsValue(dataTypeLookupKey) {
        return this.DataTypeLookupKey === dataTypeLookupKey;
    }
    createCondition(valueHost, dataTypeLookupKey, conditionfactory) {
        return this.Returns;
    }
}
describe('AutoGenerateDataTypeCheckService.RegisterDataTypeCheckGenerator', () => {
    test('Invalid parameters', () => {
        let testItem = new AutoGenerateDataTypeCheckService();
        expect(() => testItem.register(null)).toThrow(/item/);
    });
    test('Register successful', () => {
        const knownLookupKey = 'ABC';
        let testItem = new AutoGenerateDataTypeCheckService();
        expect(() => testItem.register(new TestCheckGenerator(knownLookupKey, null))).not.toThrow();
        expect(testItem.find(knownLookupKey)).not.toBeNull();
        expect(testItem.find('unknown')).toBeNull();
    });
});
describe('AutoGenerateDataTypeCheckService.AutoGenerateDataTypeCondition', () => {
    test('Not registered lookupKey returns DataTypeCheckCondition', () => {
        let services = new MockValidationServices(true, true);
        let vm = new MockValidationManager(services);
        let vh = vm.addInputValueHost('Field1', LookupKey.String, 'label');
        let testItem = services.autoGenerateDataTypeCheckService;
        let condition = null;
        expect(() => condition = testItem.autoGenerateDataTypeCondition(vh, 'ANYTHING')).not.toThrow();
        expect(condition).toBeInstanceOf(DataTypeCheckCondition);
        // really should test for the Descriptor.valueHostId to be 'Field1'
        // and Type to be DataTypeCheck, but Descriptor is protected.
    });
    test('Registered with a class that returns a condition. Returns an instance of that condition for the same ValueHostId', () => {
        let services = new MockValidationServices(true, true);
        let vm = new MockValidationManager(services);
        let vh = vm.addInputValueHost('Field1', LookupKey.String, 'label');
        let testItem = services.autoGenerateDataTypeCheckService;
        let condition = new RegExpCondition({
            type: ConditionType.RegExp,
            expressionAsString: 'test',
            valueHostId: vh.getId()
        });
        testItem.register(new TestCheckGenerator('ABC', condition));
        expect(() => condition = testItem.autoGenerateDataTypeCondition(vh, 'ABC')).not.toThrow();
        expect(condition).toBeInstanceOf(RegExpCondition);
    });
    test('Registered with a class that returns null. Returns null', () => {
        let services = new MockValidationServices(true, true);
        let vm = new MockValidationManager(services);
        let vh = vm.addInputValueHost('Field1', LookupKey.String, 'label');
        let testItem = services.autoGenerateDataTypeCheckService;
        let condition = null;
        testItem.register(new TestCheckGenerator('ABC', condition));
        expect(() => condition = testItem.autoGenerateDataTypeCondition(vh, 'ABC')).not.toThrow();
        expect(condition).toBeNull();
    });
});
//# sourceMappingURL=AutoGenerateDataTypeCheckService.test.js.map