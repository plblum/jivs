import { RegExpConditionConfig, RegExpCondition, StringLengthConditionConfig, StringLengthCondition, AllMatchConditionConfig, AllMatchCondition, DataTypeCheckConditionConfig, RequireTextConditionConfig, EqualToConditionConfig, EqualToCondition, RequireTextCondition, RangeConditionConfig } from "../../src/Conditions/ConcreteConditions";
import { ConditionFactory } from "../../src/Conditions/ConditionFactory";
import { ConditionType } from "../../src/Conditions/ConditionTypes";
import { ValueHostName } from "../../src/DataTypes/BasicTypes";
import { LookupKey } from "../../src/DataTypes/LookupKeys";
import { ConditionCategory, ConditionConfig, ConditionEvaluateResult, ICondition } from "../../src/Interfaces/Conditions";
import { ValidatorsValueHostBaseInstanceState, toIValidatorsValueHostBase } from "../../src/Interfaces/ValidatorsValueHostBase";
import { LoggingCategory, LoggingLevel } from "../../src/Interfaces/LoggerService";
import { IValidatableValueHostBase, ValueHostValidationStateChangedHandler, ValueHostValidationState } from "../../src/Interfaces/ValidatableValueHostBase";
import { ValueHostValidateResult, ValidationStatus, ValidationSeverity, ValidateOptions, IssueFound, ValidationState, BusinessLogicError, SetIssuesFoundErrorCodeMissingBehavior } from "../../src/Interfaces/Validation";
import { IValidationManager, ValidationManagerConfig } from "../../src/Interfaces/ValidationManager";
import { IValidationServices } from "../../src/Interfaces/ValidationServices";
import { IValidator, IValidatorFactory, ValidatorConfig, ValidatorValidateResult } from "../../src/Interfaces/Validator";
import { ValidatorsValueHostBaseConfig, IValidatorsValueHostBase } from "../../src/Interfaces/ValidatorsValueHostBase";
import { IValueHost, SetValueOptions, ValidTypesForInstanceStateStorage, ValueHostConfig, ValueHostInstanceState, ValueHostInstanceStateChangedHandler } from "../../src/Interfaces/ValueHost";
import { IValueHostResolver } from "../../src/Interfaces/ValueHostResolver";
import { AutoGenerateDataTypeCheckService } from "../../src/Services/AutoGenerateDataTypeCheckService";
import { DataTypeComparerService } from "../../src/Services/DataTypeComparerService";
import { DataTypeConverterService } from "../../src/Services/DataTypeConverterService";
import { DataTypeFormatterService } from "../../src/Services/DataTypeFormatterService";
import { DataTypeIdentifierService } from "../../src/Services/DataTypeIdentifierService";
import { MessageTokenResolverService } from "../../src/Services/MessageTokenResolverService";
import { ValidationServices } from "../../src/Services/ValidationServices";
import { ValidationManager } from "../../src/Validation/ValidationManager";
import { Validator } from "../../src/Validation/Validator";
import { ValidatorsValueHostBase, ValidatorsValueHostBaseGenerator } from "../../src/ValueHosts/ValidatorsValueHostBase";
import { ValueHostFactory } from "../../src/ValueHosts/ValueHostFactory";
import { CapturingLogger } from "../../src/Support/CapturingLogger";
import { AlwaysMatchesConditionType, NeverMatchesConditionType, IsUndeterminedConditionType, NeverMatchesConditionType2, UserSuppliedResultConditionType, UserSuppliedResultConditionConfig, registerTestingOnlyConditions, NeverMatchesCondition, ThrowsSevereExceptionConditionType } from "../../src/Support/conditionsForTesting";
import { createValidationServicesForTesting } from '../../src/Support/createValidationServicesForTesting';
import { MockValidationServices, MockValidationManager } from "../TestSupport/mocks";
import { ConditionWithPromiseTester } from "../Validation/Validator.test";
import { IValueHostsServices } from '../../src/Interfaces/ValueHostsServices';

import { IDisposable } from "../../src/Interfaces/General_Purpose";
import { ValidationManagerConfigBuilder } from "../../src/Validation/ValidationManagerConfigBuilder";
import { FluentValidatorBuilder } from "../../src/ValueHosts/Fluent";
import { ValidationManagerConfigBuilderFactory } from "../../src/Services/ManagerConfigBuilderFactory";
import { IManagerConfigBuilder } from "../../src/Interfaces/ManagerConfigBuilder";
import { ValueHostsManagerConfig } from "../../src/Interfaces/ValueHostsManager";
import { ValidationManagerConfigModifier } from "../../src/Validation/ValidationManagerConfigModifier";
import { ValidationManagerConfigModifierFactory } from "../../src/Services/ManagerConfigModifierFactory";
import { IManagerConfigModifier } from "../../src/Interfaces/ManagerConfigModifier";
import { IManagerConfigBuilderFactory } from "../../src/Interfaces/ManagerConfigBuilderFactory";
import { ServiceWithAccessorBase } from "../../src/Services/ServiceWithAccessorBase";
import { IManagerConfigModifierFactory } from "../../src/Interfaces/ManagerConfigModifierFactory";


/**
 * Used to test the abstract class. We won't be testing overridden abstract methods.
 */
class TestValidatorsValueHost extends ValidatorsValueHostBase<ValidatorsValueHostBaseConfig, ValidatorsValueHostBaseInstanceState>
{
    public get exposeValidators(): Array<IValidator>
    {
        return this.validators();
    }
    public get exposeServices(): IValueHostsServices {
        return this.services;
    }

    public get exposeConfig(): ValueHostConfig {
        return this.config;
    }

    public get exposeState(): ValidatorsValueHostBaseInstanceState {
        return this.instanceState;
    }    
}

const TestValueHostType = 'TestValidatorsValueHost';
/**
 * This implementation of IValueHostGenerator is actually tested in ValueHostFactory.tests.ts
 */
class TestValidatorsValueHostGenerator extends ValidatorsValueHostBaseGenerator {
    public canCreate(config: ValueHostConfig): boolean {
        return config.valueHostType === TestValueHostType;
    }
    public create(validationManager : IValidationManager, config: ValidatorsValueHostBaseConfig, state: ValidatorsValueHostBaseInstanceState): IValidatorsValueHostBase {
        return new TestValidatorsValueHost(validationManager, config, state);
    }
    // public cleanupInstanceState(state: ValidatorsValueHostBaseInstanceState, config: ValueHostConfig): void {
    // }
    // public createInstanceState(config: ValueHostConfig): ValidatorsValueHostBaseInstanceState {
    //     let state: ValidatorsValueHostBaseInstanceState = {
    //         name: config.name,
    //         value: config.initialValue,
    //         status: ValidationStatus.NotAttempted,
    //         issuesFound: null
    //     };
    //     return state;
    // }

}
class TestValueHostForValidationManagerConfigBuilder extends ValidationManagerConfigBuilder {
    public testValueHost(valueHostName: ValueHostName, dataType?: string | null, parameters?: Partial<ValidatorsValueHostBaseConfig>): FluentValidatorBuilder;
    public testValueHost(valueHostName: ValueHostName, parameters: Partial<ValidatorsValueHostBaseConfig>): FluentValidatorBuilder;    
    public testValueHost(config: Partial<ValidatorsValueHostBaseConfig>): FluentValidatorBuilder;
    // overload resolution
    public testValueHost(arg1: ValueHostName | Partial<ValidatorsValueHostBaseConfig>, arg2?: Partial<ValidatorsValueHostBaseConfig> | string | null, arg3?: Partial<ValidatorsValueHostBaseConfig>): FluentValidatorBuilder {
        return this.addValidatorsValueHost<ValidatorsValueHostBaseConfig>(TestValueHostType, arg1, arg2, arg3);
    }

}
class TestManagerConfigBuilderFactory extends ServiceWithAccessorBase
    implements IManagerConfigBuilderFactory {
    public create(configToExtend?: ValueHostsManagerConfig | undefined): IManagerConfigBuilder<ValidationManagerConfig> {
        return new TestValueHostForValidationManagerConfigBuilder(configToExtend as ValidationManagerConfig ?? this.services);
    }
}
class TestValueHostForValidationManagerConfigModifier extends ValidationManagerConfigModifier {

    public testValueHost(valueHostName: ValueHostName, dataType?: string | null, parameters?: Partial<ValidatorsValueHostBaseConfig>): FluentValidatorBuilder;
    public testValueHost(valueHostName: ValueHostName, parameters: Partial<ValidatorsValueHostBaseConfig>): FluentValidatorBuilder;    
    public testValueHost(config: Partial<ValidatorsValueHostBaseConfig>): FluentValidatorBuilder;
    // overload resolution
    public testValueHost(arg1: ValueHostName | Partial<ValidatorsValueHostBaseConfig>, arg2?: Partial<ValidatorsValueHostBaseConfig> | string | null, arg3?: Partial<ValidatorsValueHostBaseConfig>): FluentValidatorBuilder {
        return this.addValidatorsValueHost<ValidatorsValueHostBaseConfig>(TestValueHostType, arg1, arg2, arg3);
    }

}
class TestManagerConfigModifierFactory extends ServiceWithAccessorBase
implements IManagerConfigModifierFactory {
    public create(manager: IValidationManager, existingValueHostConfigs: Map<string, ValueHostConfig>): IManagerConfigModifier<ValueHostsManagerConfig> {
        return new TestValueHostForValidationManagerConfigModifier(manager, existingValueHostConfigs);
    }
}

function supportTestValueHostInServices(services: IValidationServices): void
{
    let factory = new ValueHostFactory();
    factory.register(new TestValidatorsValueHostGenerator());
    services.valueHostFactory = factory;
    services.managerConfigBuilderFactory = new TestManagerConfigBuilderFactory();
    services.managerConfigModifierFactory = new TestManagerConfigModifierFactory();
}

interface ITestSetupConfigWithMocks {
    services: MockValidationServices,
    validationManager: MockValidationManager,
    config: ValidatorsValueHostBaseConfig,
    state: ValidatorsValueHostBaseInstanceState,
    valueHost: TestValidatorsValueHost
};
interface ITestSetupConfig {
    services: IValidationServices,
    validationManager: IValidationManager,
    config: ValidatorsValueHostBaseConfig,
    state: ValidatorsValueHostBaseInstanceState,
    valueHost: TestValidatorsValueHost
};

function createValidatorsValueHostBaseConfig(fieldNumber: number = 1,
    dataType: string = LookupKey.String,
    initialValue?: any): ValidatorsValueHostBaseConfig {
    return {
        name: 'Field' + fieldNumber,
        label: 'Label' + fieldNumber,
        valueHostType: TestValueHostType,
        dataType: dataType,
        initialValue: initialValue,
        validatorConfigs: null
    };
}
function finishPartialValidatorsValueHostBaseConfig(partialConfig: Partial<ValidatorsValueHostBaseConfig> | null):
    ValidatorsValueHostBaseConfig {
    let defaultIVH = createValidatorsValueHostBaseConfig(1, LookupKey.String);
    if (partialConfig) {
        return { ...defaultIVH, ...partialConfig };
    }
    return defaultIVH;
}

function finishPartialValidatorsValueHostBaseConfigs(partialConfigs: Array<Partial<ValidatorsValueHostBaseConfig>> | null):
    Array<ValidatorsValueHostBaseConfig> | null {
    let result: Array<ValidatorsValueHostBaseConfig> = [];
    if (partialConfigs) {
        for (let i = 0; i < partialConfigs.length; i++) {
            let vhd = partialConfigs[i];
            result.push(finishPartialValidatorsValueHostBaseConfig(vhd));
        }
    }

    return result;
}
function createValidatorConfig(condConfig: ConditionConfig | null): ValidatorConfig {
    return {
        conditionConfig: condConfig,
        errorMessage: 'Local',
        summaryMessage: 'Summary',
    };
}
function finishPartialValidatorConfig(validatorConfig: Partial<ValidatorConfig> | null):
    ValidatorConfig {
    let defaultIVD = createValidatorConfig(null);
    if (validatorConfig) {
        return { ...defaultIVD, ...validatorConfig };
    }
    return defaultIVD;
}

function finishPartialValidatorConfigs(validatorConfigs: Array<Partial<ValidatorConfig>> | null):
    Array<ValidatorConfig> {
    let result: Array<ValidatorConfig> = [];
    if (validatorConfigs) {
        let defaultIVD = createValidatorConfig(null);
        for (let i = 0; i < validatorConfigs.length; i++) {
            let vd = validatorConfigs[i];
            result.push(finishPartialValidatorConfig(vd));
        }
    }

    return result;
}

function createValidatorsValueHostBaseInstanceState(fieldNumber: number = 1): ValidatorsValueHostBaseInstanceState {
    return {
        name: 'Field' + fieldNumber,
        value: undefined,
        issuesFound: null,
        status: ValidationStatus.NotAttempted
    };
}
function finishPartialValidatorsValueHostBaseInstanceState(partialState: Partial<ValidatorsValueHostBaseInstanceState> | null): ValidatorsValueHostBaseInstanceState {
    let defaultIVS = createValidatorsValueHostBaseInstanceState(1);
    if (partialState) {
        return { ...defaultIVS, ...partialState };
    }
    return defaultIVS;
}



/**
 * Returns an ValueHost (ValidatorsValueHostBase subclass) ready for testing.
 * @param partialIVHConfig - Provide just the properties that you want to test.
 * Any not supplied but are required will be assigned using these rules:
 * name: 'Field1',
 * label: 'Label1',
 * valueHostType: 'Test',
 * DataType: LookupKey.String,
 * InitialValue: 'DATA'
 * @param partialState - Use the default state by passing null. Otherwise pass
 * a state. Your state will override default values. To avoid overriding,
 * pass the property with a value of undefined.
 * These are the default values
 * name: 'Test'
 * Value: undefined
 * InputValue: undefined
 * IssuesFound: null,
 * ValidationStatus: NotAttempted
 * @returns An object with all of the parts that were setup including 
 * ValidationManager, Services, ValueHosts, the complete Config,
 * and the state.
 */
function setupValidatorsValueHostBase(
    partialIVHConfig?: Partial<ValidatorsValueHostBaseConfig> | null,
    partialState?: Partial<ValidatorsValueHostBaseInstanceState> | null): ITestSetupConfigWithMocks {
    let services = new MockValidationServices(true, true);
    supportTestValueHostInServices(services);

    let vm = new MockValidationManager(services);
    let updatedConfig = finishPartialValidatorsValueHostBaseConfig(partialIVHConfig ?? null);
    let updatedState = finishPartialValidatorsValueHostBaseInstanceState(partialState ?? null);

    let vh = vm.addValueHost(updatedConfig, updatedState) as TestValidatorsValueHost;

    //new ValidatorsValueHostBase(vm, updatedConfig, updatedState);
    return {
        services: services,
        validationManager: vm,
        config: updatedConfig,
        state: updatedState,
        valueHost: vh as TestValidatorsValueHost
    };
}


/**
 * Creates a configuration where you can call validate() and test various results.
 * @param partialValidatorConfigs - Always provide a list of the validatorConfigs in the desired order.
 * If null, no validators are made available to validate
 * @param partialValidatorsState - Use to supply initial Validators and Value properties. Any property
 * not supplied will be provided.
 * @returns Configuration that has been setup. Use valueHost to invoke validation functions.
 */
function setupValidatorsValueHostBaseForValidate(
    partialValidatorConfigs: Array<Partial<ValidatorConfig>> | null,
    partialValidatorsState: Partial<ValidatorsValueHostBaseInstanceState> | null,
    vhGroup?: string | null): ITestSetupConfigWithMocks {

    let inputValueConfig: Partial<ValidatorsValueHostBaseConfig> = {
        validatorConfigs: partialValidatorConfigs ?
            finishPartialValidatorConfigs(partialValidatorConfigs) :
            undefined
    };
    if (vhGroup !== undefined)
        inputValueConfig.group = vhGroup;

    let updatedState = finishPartialValidatorsValueHostBaseInstanceState(
        { ...partialValidatorsState });

    return setupValidatorsValueHostBase(inputValueConfig, updatedState);
}


describe('ValidatorsValueHostBase.getValidator', () => {
    test('Request errorCode without any validators setup return null', () => {
        let setup = setupValidatorsValueHostBase();
        expect(setup.valueHost.getValidator('anything')).toBeNull();
    });

    test('With 1 validator registered, request its errorCode. Returns the correct Validator', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: ConditionType.RequireText
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        let result = setup.valueHost.getValidator(ConditionType.RequireText);
        expect(result).toBeInstanceOf(Validator);
        expect((result as Validator).errorCode).toBe(ConditionType.RequireText);
    });
    test('With 1 validator registered, request a different errorCode. Returns null', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: ConditionType.RequireText
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        (setup.services.conditionFactory as ConditionFactory).register<RegExpConditionConfig>(
            ConditionType.RegExp, (config) => new RegExpCondition(config));
        let result = setup.valueHost.getValidator(ConditionType.RegExp);
        expect(result).toBeNull();
    });
    test('With 4 validators registered, request each and it returns the correct Validator', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: ConditionType.RequireText
                }
            },
            {
                conditionConfig: {
                    conditionType: ConditionType.RegExp
                }
            },
            {
                conditionConfig: {
                    conditionType: ConditionType.StringLength
                }
            },
            {
                conditionConfig: {
                    conditionType: ConditionType.All
                }
            },
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        let cf = setup.services.conditionFactory as ConditionFactory;
        cf.register<RegExpConditionConfig>(
            ConditionType.RegExp, (config) => new RegExpCondition(config));
        cf.register<StringLengthConditionConfig>
            (ConditionType.StringLength, (config) => new StringLengthCondition(config));
        cf.register<AllMatchConditionConfig>
            (ConditionType.All, (config) => new AllMatchCondition(config));


        let result = setup.valueHost.getValidator(ConditionType.RequireText);
        expect(result).toBeInstanceOf(Validator);
        expect((result as Validator).errorCode).toBe(ConditionType.RequireText);
        result = setup.valueHost.getValidator(ConditionType.RegExp);
        expect(result).toBeInstanceOf(Validator);
        expect((result as Validator).errorCode).toBe(ConditionType.RegExp);
        result = setup.valueHost.getValidator(ConditionType.StringLength);
        expect(result).toBeInstanceOf(Validator);
        expect((result as Validator).errorCode).toBe(ConditionType.StringLength);
        result = setup.valueHost.getValidator(ConditionType.All);
        expect(result).toBeInstanceOf(Validator);
        expect((result as Validator).errorCode).toBe(ConditionType.All);
        result = setup.valueHost.getValidator('Anything');
        expect(result).toBeNull();
    });
});
/**
 * For testing ValidatorsValueHostBase.validate (but not the logic of an individual Validator.validate).
 * @param validatorConfigs - Always provide a list of the validatorConfigs in the desired order.
 * If null, no validators are made available to validate
 * @param inputValueState - Use to supply initial InputValue and Value properties. Any property
 * not supplied will be provided.
 * @param expectedValidationStatusCode 
 * @param expectedIssuesFound - This will be matched by Jest's isEqual.
 */
function testValidateFunctionHasResult(validatorConfigs: Array<Partial<ValidatorConfig>> | null,
    inputValueState: Partial<ValidatorsValueHostBaseInstanceState> | null,
    expectedValidationStatusCode: ValidationStatus,
    expectedIssuesFound: Array<IssueFound> | null,
    validationGroupForValueHost?: string | undefined,
    validationGroupForValidateFn?: string | undefined,
    expectedStateChanges: number = 1): ITestSetupConfigWithMocks {

    let setup = setupValidatorsValueHostBaseForValidate(validatorConfigs, inputValueState, validationGroupForValueHost);
    setup.services.loggerService.minLevel = LoggingLevel.Debug;

    let vrDetails: ValueHostValidateResult | null = null;
    expect(() => vrDetails = setup.valueHost.validate({ group: validationGroupForValidateFn })).not.toThrow();

    expect(vrDetails).not.toBeNull();
    expect(vrDetails!.status).toBe(expectedValidationStatusCode);
    expect(vrDetails!.issuesFound).toEqual(expectedIssuesFound);
    expect(vrDetails!.pending).toBeUndefined();

    let stateChanges = setup.validationManager.getHostStateChanges();
    expect(stateChanges).not.toBeNull();
    expect(stateChanges.length).toBe(expectedStateChanges);

    return setup;
}
/**
 * For testing ValidatorsValueHostBase.validate (but not the logic of an individual Validator.validate).
 * @param validatorConfigs - Always provide a list of the validatorConfigs in the desired order.
 * If null, no validators are made available to validate
 * @param inputValueState - Use to supply initial InputValue and Value properties. Any property
 * not supplied will be provided.
 * @param expectedValidationStatusCode 
 * @param expectedIssuesFound - This will be matched by Jest's isEqual.
 */
function testValidateFunctionIsNull(validatorConfigs: Array<Partial<ValidatorConfig>> | null,
    inputValueState: Partial<ValidatorsValueHostBaseInstanceState> | null,
    validationGroupForValueHost?: string | undefined,
    validationGroupForValidateFn?: string | undefined,
    expectedStateChanges: number = 1): ITestSetupConfigWithMocks {

    let setup = setupValidatorsValueHostBaseForValidate(validatorConfigs, inputValueState, validationGroupForValueHost);
    setup.services.loggerService.minLevel = LoggingLevel.Debug;
    let vrDetails: ValueHostValidateResult | null = null;
    expect(() => vrDetails = setup.valueHost.validate({ group: validationGroupForValidateFn })).not.toThrow();
    expect(vrDetails).toBeNull();
    let stateChanges = setup.validationManager.getHostStateChanges();
    expect(stateChanges).not.toBeNull();
    expect(stateChanges.length).toBe(expectedStateChanges);

    return setup;
}


function createIssueFound(errorCode: string,
    severity: ValidationSeverity = ValidationSeverity.Error,
    errorMessage: string = 'Local',
    summaryMessage: string = 'Summary'): IssueFound {
    return {
        valueHostName: 'Field1',
        errorCode: errorCode,
        severity: severity,
        errorMessage: errorMessage,
        summaryMessage: summaryMessage
    };
}
describe('constructor and resulting property values', () => {

    test('constructor with valid parameters created and sets up Services, Config, and InstanceState', () => {
        let services = new MockValidationServices(true, true);
        let vm = new MockValidationManager(services);
        let testItem: TestValidatorsValueHost | null = null;
        expect(()=> testItem = new TestValidatorsValueHost(vm, {
            name: 'Field1',
            valueHostType: TestValueHostType,
            validatorConfigs: []
            },
            {
                name: 'Field1',
                status: ValidationStatus.NotAttempted,
                issuesFound: null,
                value: undefined
            })).not.toThrow();

        expect(testItem!.valueHostsManager).toBe(vm);

        expect(testItem!.getName()).toBe('Field1');
        expect(testItem!.getLabel()).toBe('');
        expect(testItem!.getDataType()).toBeNull();
        expect(testItem!.getValue()).toBeUndefined();
        expect(testItem!.isChanged).toBe(false);
        expect(testItem!.isValid).toBe(true);
        expect(testItem!.asyncProcessing).toBe(false);
        expect(testItem!.corrected).toBe(false);        
    });
});


describe('ValidatorsValueHostBase.validate', () => {
    //NOTE: Validator tests already handle testing Validator property of Enabled, Enabler,
    // and validate's Group parameter. When those skip the condition, we expect a ConditionEvaluateResult of Undetermined
    // which is evaluated in these tests.
    test('Without Validators is null', () => {
        testValidateFunctionIsNull(null, null);
    });
    test('With 1 Condition evaluating as Match is ValidatorResult.Valid, IssuesFound = null', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Valid, null);
    });
    test('With 1 Condition evaluating as NoMatch is ValidatorResult.Invalid, IssuesFound = 1', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound(NeverMatchesConditionType));
        testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Invalid, issuesFound);
    });
    test('With 1 Condition evaluating as Undetermined returns null', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: IsUndeterminedConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        testValidateFunctionIsNull(ivConfigs, state);
    });
    test('With 1 Condition that throws logs that throw and throw bubbles up', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: ThrowsSevereExceptionConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        let logger = setup.services.loggerService as CapturingLogger;        
        let vrDetails: ValueHostValidateResult | null = null;
        expect(() => vrDetails = setup.valueHost.validate()).toThrow('Always Throws');
        expect(logger.findMessage('Always Throws', LoggingLevel.Error)).toBeTruthy();
    });    
    test('With 2 Conditions evaluating as Match is ValidatorResult.Valid, IssuesFound = null', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                },
                errorMessage: '1'
            },
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                },
                errorMessage: '2'
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Valid, null);
    });
    test('With 2 Conditions evaluating as Undetermined returns null', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: IsUndeterminedConditionType
                },
                errorCode: '1'
            },
            {
                conditionConfig: {
                    conditionType: IsUndeterminedConditionType
                },
                errorCode: '2'
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        testValidateFunctionIsNull(ivConfigs, state);
    });
    test('With Validator of Severe evaluating as NoMatch, second Condition is skipped even though it would be NoMatch, IssuesFound = 1', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                },
                severity: ValidationSeverity.Severe
            },
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                },
                errorMessage: '2'
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound(NeverMatchesConditionType, ValidationSeverity.Severe));
        testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Invalid, issuesFound);

    });
    test('With Validator of Severe evaluating as Match, second Condition is evaluated and is NoMatch, IssuesFound = 1 with second condition', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                },
                severity: ValidationSeverity.Severe
            },
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound(NeverMatchesConditionType));
        testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Invalid, issuesFound);

    });
    test('With Validator of Severe evaluating as Undetermined, second Condition is evaluated and is NoMatch, IssuesFound = 1 with second condition', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig:
                {
                    conditionType: IsUndeterminedConditionType
                },
                severity: ValidationSeverity.Severe
            },
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound(NeverMatchesConditionType));
        testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Invalid, issuesFound);

    });
    test('With Validator of Warning evaluating as NoMatch, second Condition is evaluated and is NoMatch, IssuesFound = 2 with both conditions', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                },
                severity: ValidationSeverity.Warning,
                errorMessage: '1'
            },
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                },
                errorMessage: '2'
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound(NeverMatchesConditionType, ValidationSeverity.Warning, "1"));
        issuesFound.push(createIssueFound(NeverMatchesConditionType, ValidationSeverity.Error, "2"));
        testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Invalid, issuesFound);

    });
    test('With Validator of Warning evaluating as Undetermined, second Condition is evaluated and is NoMatch, IssuesFound = 1 with second condition', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: IsUndeterminedConditionType
                },
                severity: ValidationSeverity.Warning
            },
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound(NeverMatchesConditionType));
        testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Invalid, issuesFound);

    });
    test('With Validator of Warning evaluating as Match, second Condition is evaluated and is NoMatch, IssuesFound = 1 with second condition', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                },
                severity: ValidationSeverity.Warning
            },
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound(NeverMatchesConditionType));
        testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Invalid, issuesFound);

    });
    test('With Validator of Warning evaluating as NoMatch, second Condition is evaluated and is Match, IssuesFound = 1 with first condition. ValidationStatus is Valid', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                },
                severity: ValidationSeverity.Warning
            },
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound(NeverMatchesConditionType, ValidationSeverity.Warning));
        testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Valid, issuesFound);

    });
    test('With Validator of Warning evaluating as NoMatch and no second condition, ValidationStatus = Valid, IssuesFound = 1', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                },
                severity: ValidationSeverity.Warning
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound(NeverMatchesConditionType, ValidationSeverity.Warning));
        testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Valid, issuesFound);

    });
    test('With only 1 Validator, and its set to Enabled=false, acts like there are no validators. Returns null', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                },
                enabled: false
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        testValidateFunctionIsNull(ivConfigs, state);

    });
    function testGroups(valueHostGroup: string, validateGroup: string, expectedResult: ValidationStatus | null, expectedStateChanges: number = 1): void {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                },
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let issueFound: IssueFound | null = null;
        if (expectedResult === ValidationStatus.Invalid)
            issueFound = {
                errorCode: NeverMatchesConditionType,
                errorMessage: 'Local',
                summaryMessage: 'Summary',
                severity: ValidationSeverity.Error,
                valueHostName: 'Field1'
            };
        let setup: ITestSetupConfigWithMocks;
        if (expectedResult)
        {
            setup = testValidateFunctionHasResult(ivConfigs, state, expectedResult,
                issueFound ? [issueFound] : null, valueHostGroup, validateGroup, expectedStateChanges);
        }
        else
            setup = testValidateFunctionIsNull(ivConfigs, state, valueHostGroup, validateGroup, expectedStateChanges);
        let logger = setup.services.loggerService as CapturingLogger;
        if (expectedResult === null) {
            expect(logger.findMessage('Group names do not match', LoggingLevel.Info)).toBeTruthy();
        }
        else
            expect(logger.findMessage('Validation result', LoggingLevel.Info)).toBeTruthy();            
    }

    test('Group test. ValidatorsValueHostBase has Group name but validate has empty string for group name. Validation occurs and returns an issue', () => {
        testGroups('GROUPA', '', ValidationStatus.Invalid);
    });
    test('Group test. ValidatorsValueHostBase has Group name but validate has * for group name. Validation occurs and returns an issue', () => {
        testGroups('GROUPA', '*', ValidationStatus.Invalid);
    });
    test('Group test. ValidatorsValueHostBase has Group name and validate has same group name. Validation occurs and returns an issue', () => {
        testGroups('GROUPA', 'GROUPA', ValidationStatus.Invalid);
    });

    test('Group test. ValidatorsValueHostBase has Group name and validate has same group name but case mismatch. Validation occurs and returns an issue', () => {
        testGroups('GROUPA', 'groupa', ValidationStatus.Invalid);
    });
    test('Group test. ValidatorsValueHostBase has Group name but validate has a different group name. Validation skipped and result is Valid', () => {
        testGroups('GROUPA', 'GROUPB', null, 0);
    });

    function TestGroupUsingOverride(valueHostGroup: string, overriddenGroup: string,
        validateGroup: string, expectedResult: ValidationStatus | null): void {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                },
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};

        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state, valueHostGroup);
        let modifier = setup.validationManager.startModifying() as TestValueHostForValidationManagerConfigModifier;
        modifier.testValueHost('Field1', null, { group: overriddenGroup});
        modifier.apply();
        setup.valueHost = setup.validationManager.getValueHost('Field1') as TestValidatorsValueHost;    // because apply discards the previous instance

        let result = setup.valueHost.validate({ group: validateGroup });
        if (expectedResult === null)
            expect(result).toBeNull();
        else
            expect(result!.status).toBe(expectedResult);
    }
    test('Group test where group is modified and is a match to the supplied group and original group. ValidatorsValueHostBase has Group name but validate has a different group name. Validation occurs', () => {
        TestGroupUsingOverride('GROUPA', 'GROUPA', 'GROUPA', ValidationStatus.Invalid)
    });
    test('Group test where group is modified and is a match to the supplied group but not the original. ValidatorsValueHostBase has Group name but validate has a different group name. Validation occurs', () => {
        TestGroupUsingOverride('GROUPB', 'GROUPA', 'GROUPA', ValidationStatus.Invalid)
    });
    test('Group test where group is modified and is not a match to the supplied group. ValidatorsValueHostBase has Group name but validate has a different group name. ValidationStatus = undetermined', () => {
        TestGroupUsingOverride('GROUPA', 'GROUPB', 'GROUPA', null)
    });
    test('validate one ValueHost with validators that results in Valid. onValueHostValidationStateChanged called.', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        let results: Array<ValueHostValidationState> = [];
        setup.validationManager.onValueHostValidationStateChanged = (valueHost, validateResult) => {
            results.push(validateResult);
        };
        setup.valueHost.validate();
        expect(results).toEqual([
            <ValueHostValidationState>{
                issuesFound: null,
                isValid: true,
                doNotSave: false,
                asyncProcessing: false,
                status: ValidationStatus.Valid,
                corrected: false
            }
        ]);
    });
    test('validate one ValueHost with validators that results in Invalid. onValueHostValidationStateChanged called.', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                },
                errorMessage: 'Error', 
                summaryMessage: 'Error'
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        let results: Array<ValueHostValidationState> = [];
        setup.validationManager.onValueHostValidationStateChanged = (valueHost, validateResult) => {
            results.push(validateResult);
        };
        setup.valueHost.validate();
        expect(results).toEqual([
            <ValueHostValidationState>{
                issuesFound: [{
                    errorCode: NeverMatchesConditionType,
                    valueHostName: 'Field1',
                    severity: ValidationSeverity.Error,
                    errorMessage: 'Error',
                    summaryMessage: 'Error'
                }],
                isValid: false,
                doNotSave: true,
                asyncProcessing: false,
                status: ValidationStatus.Invalid,
                corrected: false
            }
        ]);

    });
    test('With loggingLevel=Debug, expect validate() to log Validating ValueHostName [hostname]', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                }
            }
        ];

        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, {});
        let logger = setup.services.loggerService as CapturingLogger;
        logger.minLevel = LoggingLevel.Debug;
        setup.valueHost.validate();
        expect(logger.findMessage('Validating ValueHost "Field1"', LoggingLevel.Debug)).toBeTruthy();
    });    
    test('With ValueHost.isEnabled=false, return null and log', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = { enabled: false };
        let setup = testValidateFunctionIsNull(ivConfigs, state, undefined, undefined, 0);
        let logger = setup.services.loggerService as CapturingLogger;
        expect(logger.findMessage('ValueHost "Field1" is disabled', LoggingLevel.Debug)).toBeTruthy();
    });    
});

describe('validate() and its impact on isValid and ValidationStatus', () => {

    test('Without Validators IsValid=true, ValidationStatus = Undetermined', () => {
        let setup = setupValidatorsValueHostBaseForValidate(null, null);
        setup.valueHost.validate();
        expect(setup.valueHost.isValid).toBe(true);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Undetermined);
    });
    test('With 1 Condition evaluating as Match. isValid is true, ValidationStatus=Valid', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        setup.valueHost.validate();
        expect(setup.valueHost.isValid).toBe(true);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Valid);
    });
    test('With 1 Condition evaluating as NoMatch. isValid is false. ValidationStatus=Invalid', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {
        };
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        setup.valueHost.validate();
        expect(setup.valueHost.isValid).toBe(false);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Invalid);
    });
    test('Without Validators but have a BusinessLogicError (Error), isValid=false, ValidationStatus = Invalid', () => {
        let setup = setupValidatorsValueHostBaseForValidate(null, null);
        let result = setup.valueHost.setBusinessLogicError({
            errorMessage: 'ERROR',
        });
        expect(result).toBe(true);
        setup.valueHost.validate();
        expect(setup.valueHost.isValid).toBe(false);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Invalid);
    });
    test('Without Validators but have a BusinessLogicError (Warning), isValid=true, ValidationStatus = Undetermined because warning does not change anything and no validators means Undetermined', () => {
        let setup = setupValidatorsValueHostBaseForValidate(null, null);
        let result = setup.valueHost.setBusinessLogicError({
            errorMessage: 'WARNING',
            severity: ValidationSeverity.Warning
        });
        expect(result).toBe(true);
        setup.valueHost.validate();
        expect(setup.valueHost.isValid).toBe(true);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Undetermined);
    });
    test('setBusinessLogicError with same data back-to-back with different error codes returns true on both calls. Expect two IssuesFound', () => {
        let setup = setupValidatorsValueHostBaseForValidate(null, null);
        let result = setup.valueHost.setBusinessLogicError({
            errorCode: 'TEST1',
            errorMessage: 'ERROR',
        });
        expect(result).toBe(true);
        result = setup.valueHost.setBusinessLogicError({
            errorCode: 'TEST2',
            errorMessage: 'ERROR',
        });
        expect(result).toBe(true);
        let issuesFound = setup.valueHost.getIssuesFound();
        expect(issuesFound).not.toBeNull();
        expect(issuesFound!.length).toBe(2);
    });    
    test('setBusinessLogicError with same data back-to-back with the same error codes returns true on first and false on second due to no real change. Only one IssueFound', () => {
        let setup = setupValidatorsValueHostBaseForValidate(null, null);
        let result = setup.valueHost.setBusinessLogicError({
            errorCode: 'TEST',
            errorMessage: 'ERROR',
        });
        expect(result).toBe(true);
        result = setup.valueHost.setBusinessLogicError({
            errorCode: 'TEST',
            errorMessage: 'ERROR',
        });
        expect(result).toBe(false);
        let issuesFound = setup.valueHost.getIssuesFound();
        expect(issuesFound).not.toBeNull();
        expect(issuesFound!.length).toBe(1);
    });    
    test('With 1 Condition evaluating as NoMatch and have a BusinessLogicError (Warning). isValid is false due to NoMatch. ValidationStatus=Invalid', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {
        };
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        setup.valueHost.setBusinessLogicError({
            errorMessage: 'WARNING',
            severity: ValidationSeverity.Warning
        });
        setup.valueHost.validate();
        expect(setup.valueHost.isValid).toBe(false);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Invalid);
    });
    test('With 1 Condition evaluating as Match and have a BusinessLogicError (Error). isValid is false due to BusinessLogicError. ValidationStatus=Invalid', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {
        };
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        setup.valueHost.setBusinessLogicError({
            errorMessage: 'ERROR',
            severity: ValidationSeverity.Error
        });
        setup.valueHost.validate();
        expect(setup.valueHost.isValid).toBe(false);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Invalid);
    });
    test('With 1 Condition evaluating as Match and have a BusinessLogicError (Warning). isValid is true. ValidationStatus=Valid', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {
        };
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        setup.valueHost.setBusinessLogicError({
            errorMessage: 'WARNING',
            severity: ValidationSeverity.Warning
        });
        setup.valueHost.validate();
        expect(setup.valueHost.isValid).toBe(true);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Valid);
    });
    test('With ValueHost.isEnabled=false, Without Validators but have a BusinessLogicError (Error), everything continues to work plus there is a log entry so when re-enabled it is there', () => {
        let setup = setupValidatorsValueHostBaseForValidate(null, null);
        setup.valueHost.setEnabled(false);
        setup.valueHost.setBusinessLogicError({
            errorMessage: 'ERROR',
        });
        let logger = setup.services.loggerService as CapturingLogger;
        expect(logger.findMessage('BusinessLogicError applied on disabled ValueHost', LoggingLevel.Warn)).toBeTruthy();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Disabled);
        let issuesFound = setup.valueHost.getIssuesFound();
        expect(issuesFound).toBeNull();
        setup.valueHost.setEnabled(true);
        issuesFound = setup.valueHost.getIssuesFound();
        expect(issuesFound).not.toBeNull();
        expect(issuesFound!.length).toBe(1);        
    });    
    test('Confirm the OnValueHostValidate event is called and captures the correct ValidationStatus', () => {
        let onValidateResult: ValueHostValidationState | null = null;

        let vmConfig: ValidationManagerConfig = {
            services: createValidationServicesForTesting(),
            valueHostConfigs: [],
            onValueHostValidationStateChanged: (vh, vr) => {
                onValidateResult = vr;
            }
        };
        supportTestValueHostInServices(vmConfig.services);
        let vm = new ValidationManager(vmConfig);
        let vh = vm.addValueHost(<ValidatorsValueHostBaseConfig>{
            valueHostType: TestValueHostType,
            name: 'Field1',
            validatorConfigs: [
                {
                    conditionConfig: {
                        conditionType: AlwaysMatchesConditionType
                    }
                }
            ]
        }, null) as TestValidatorsValueHost;
        let expectedIssueFound: IssueFound = {
            errorMessage: 'BL_ERROR',
            severity: ValidationSeverity.Error,
            valueHostName: 'Field1',
            summaryMessage: 'BL_ERROR',
            errorCode: 'GENERATED_0'
        };

        let result = vh.setBusinessLogicError({
            errorMessage: 'BL_ERROR',
        });
        expect(result).toBe(true);
        expect(onValidateResult).toEqual(<ValueHostValidationState>{
            issuesFound: [expectedIssueFound],
            doNotSave: true,
            isValid: false,
            asyncProcessing: false,
            status: ValidationStatus.Invalid,
            corrected: false
        });
    });    
    test('Confirm the OnValueHostValidate event is setup but not called due to option.skipCallback', () => {
        let onValidateResult: ValueHostValidationState | null = null;

        let vmConfig: ValidationManagerConfig = {
            services: createValidationServicesForTesting(),
            valueHostConfigs: [],
            onValueHostValidationStateChanged: (vh, vr) => {
                onValidateResult = vr;
            }
        };
        supportTestValueHostInServices(vmConfig.services);
        let vm = new ValidationManager(vmConfig);
        let vh = vm.addValueHost(<ValidatorsValueHostBaseConfig>{
            valueHostType: TestValueHostType,
            name: 'Field1',
            validatorConfigs: [
                {
                    conditionConfig: {
                        conditionType: AlwaysMatchesConditionType
                    }
                }
            ]
        }, null) as TestValidatorsValueHost;

        let result = vh.setBusinessLogicError({
            errorMessage: 'BL_ERROR',
        }, { skipCallback: true});
        expect(result).toBe(true);
        expect(onValidateResult).toBeNull();
    });        
    test('Ensure Require sorts first amongst several Conditions, placing Require last. Demonstrated by stopping when RequireTextCondition is NoMatch while others return an error', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            },
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType2
                }
            },
            {
                conditionConfig: {
                    conditionType: ConditionType.RequireText
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {
        };
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        setup.valueHost.setValue('');
        let vr = setup.valueHost.validate();
        expect(vr).toBeDefined();
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound(ConditionType.RequireText, ValidationSeverity.Severe));
        expect(vr!.issuesFound).toEqual(issuesFound);
    });
    test('Ensure Category=DataTypeCheck sorts first amongst several Conditions, placing DataTypeCheck last. Demonstrated by stopping when DataTypeCheckCondition is NoMatch while others return an error', () => {

        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            },
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType2
                }
            },
            { // emulate DataTypeCheck because the real condition needs Input Value
                conditionConfig: <UserSuppliedResultConditionConfig>{
                    conditionType: UserSuppliedResultConditionType,
                    category: ConditionCategory.DataTypeCheck,
                    result: ConditionEvaluateResult.NoMatch
                },
                errorCode: 'DTC'
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {
        };
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        let vr = setup.valueHost.validate();
        expect(vr).toBeDefined();
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound('DTC', ValidationSeverity.Severe));
        expect(vr!.issuesFound).toEqual(issuesFound);
    });
    test('Ensure Category=Require sorts first, Category=DataTypeCheck sorts second amongst several Conditions, placing Require last. Demonstrated by stopping when DataTypeCheckCondition is NoMatch while others return an error', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            },
            
            { // emulate DataTypeCheck because the real condition needs Input Value
                conditionConfig: <UserSuppliedResultConditionConfig>{
                    conditionType: UserSuppliedResultConditionType,
                    category: ConditionCategory.DataTypeCheck,
                    result: ConditionEvaluateResult.NoMatch
                },
                errorCode: 'DTC'
            }, {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType2
                }
            },
            { // emulate RequireText because the real condition needs Input Value
                conditionConfig: <UserSuppliedResultConditionConfig>{
                    conditionType: UserSuppliedResultConditionType,
                    category: ConditionCategory.Require,
                    result: ConditionEvaluateResult.Match
                },
                errorCode: 'RT'
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {
        };
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);

        let vr = setup.valueHost.validate();
        expect(vr).toBeDefined();
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound('DTC', ValidationSeverity.Severe));
        expect(vr!.issuesFound).toEqual(issuesFound);
    });
});
describe('corrected property', () => {

    test('Validate without validators, corrected=false', () => {
        let setup = setupValidatorsValueHostBaseForValidate(null, null);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(false);
    });
    test('When initial state has corrected=true, corrected=true', () => {
        let setup = setupValidatorsValueHostBaseForValidate(null, {
            corrected: true,
            name: 'Field1'
        });
        expect(setup.valueHost.corrected).toBe(true);
    });
    test('From Invalid->Valid, corrected=true', () => {
        let setup = setupValidatorsValueHostBaseForValidate([{
            conditionConfig: {
                conditionType: NeverMatchesConditionType,
            },
            errorMessage: 'NeverMatch',
            enabled: true
        },
        {
            conditionConfig: {
                conditionType: AlwaysMatchesConditionType,
            },
            errorMessage: 'Never shown',
            enabled: false
        }], null);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(false);
        setup.valueHost.getValidator(NeverMatchesConditionType)?.setEnabled(false);
        setup.valueHost.getValidator(AlwaysMatchesConditionType)?.setEnabled(true);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(true);
    });
    test('From Invalid->Valid->Valid, corrected=true', () => {
        let setup = setupValidatorsValueHostBaseForValidate([{
            conditionConfig: {
                conditionType: NeverMatchesConditionType,
            },
            errorMessage: 'NeverMatch',
            enabled: true
        },
        {
            conditionConfig: {
                conditionType: AlwaysMatchesConditionType,
            },
            errorMessage: 'Never shown',
            enabled: false
        }], null);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(false);
        setup.valueHost.getValidator(NeverMatchesConditionType)?.setEnabled(false);
        setup.valueHost.getValidator(AlwaysMatchesConditionType)?.setEnabled(true);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(true);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(true);
    });
    test('From Invalid->Valid->Invalid, corrected=false', () => {
        let setup = setupValidatorsValueHostBaseForValidate([{
            conditionConfig: {
                conditionType: NeverMatchesConditionType,
            },
            errorMessage: 'NeverMatch',
            enabled: true
        },
        {
            conditionConfig: {
                conditionType: AlwaysMatchesConditionType,
            },
            errorMessage: 'Never shown',
            enabled: false
        }], null);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(false);
        setup.valueHost.getValidator(NeverMatchesConditionType)?.setEnabled(false);
        setup.valueHost.getValidator(AlwaysMatchesConditionType)?.setEnabled(true);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(true);
        setup.valueHost.getValidator(NeverMatchesConditionType)?.setEnabled(true);
        setup.valueHost.getValidator(AlwaysMatchesConditionType)?.setEnabled(false);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(false);
    });
    test('From Invalid->Valid->NotAttempted, corrected=false', () => {
        let setup = setupValidatorsValueHostBaseForValidate([{
            conditionConfig: {
                conditionType: NeverMatchesConditionType,
            },
            errorMessage: 'NeverMatch',
            enabled: true
        },
        {
            conditionConfig: {
                conditionType: AlwaysMatchesConditionType,
            },
            errorMessage: 'Never shown',
            enabled: false
        }], null);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(false);
        setup.valueHost.getValidator(NeverMatchesConditionType)?.setEnabled(false);
        setup.valueHost.getValidator(AlwaysMatchesConditionType)?.setEnabled(true);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(true);
        setup.valueHost.clearValidation();
        expect(setup.valueHost.corrected).toBe(false);
    });
    test('From Invalid->Valid->NeedsValidation, corrected=false', () => {
        let setup = setupValidatorsValueHostBaseForValidate([{
            conditionConfig: {
                conditionType: NeverMatchesConditionType,
            },
            errorMessage: 'NeverMatch',
            enabled: true
        },
        {
            conditionConfig: {
                conditionType: AlwaysMatchesConditionType,
            },
            errorMessage: 'Never shown',
            enabled: false
        }], null);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(false);
        setup.valueHost.getValidator(NeverMatchesConditionType)?.setEnabled(false);
        setup.valueHost.getValidator(AlwaysMatchesConditionType)?.setEnabled(true);
        setup.valueHost.validate();
        expect(setup.valueHost.corrected).toBe(true);
        setup.valueHost.setValue('A');
        expect(setup.valueHost.corrected).toBe(false);
    });
    test('From state has corrected=true ->NeedsValidation, corrected=false', () => {
        let setup = setupValidatorsValueHostBaseForValidate(null, {
            corrected: true,
            name: 'Field1',
            status: ValidationStatus.Valid
        });
        setup.valueHost.setValue('A');
        expect(setup.valueHost.corrected).toBe(false);
    });
    test('onValueHostValidationStateChanged setup. corrected reported as true after Invalid->Valid and omitted any other time', () => {
        let onValidateResult: ValueHostValidationState | null = null;

        let vmConfig: ValidationManagerConfig = {
            services: createValidationServicesForTesting(),
            valueHostConfigs: [],
            onValueHostValidationStateChanged: (vh, vr) => {
                onValidateResult = vr;
            }
        };
        supportTestValueHostInServices(vmConfig.services);
        let vm = new ValidationManager(vmConfig);
        let vh = vm.addValueHost(<ValidatorsValueHostBaseConfig>{
            valueHostType: TestValueHostType,
            name: 'Field1',
            validatorConfigs: [{
                conditionConfig: {
                    conditionType: NeverMatchesConditionType,
                },
                errorMessage: 'NeverMatch',
                enabled: true
            },
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType,
                },
                errorMessage: 'Never shown',
                enabled: false
            }]
        }, null) as TestValidatorsValueHost;

        let neverMatchIssueFound: IssueFound = {
            errorCode: NeverMatchesConditionType,
            errorMessage: 'NeverMatch',
            summaryMessage: 'NeverMatch',
            valueHostName: 'Field1',
            severity: ValidationSeverity.Error
        };

        let snapshot = vm.validate(); // ensure we have an invalid state without business logic
        expect(snapshot).toEqual(<ValidationState>{
            isValid: false,
            doNotSave: true,
            issuesFound: [neverMatchIssueFound],
            asyncProcessing: false,
        });
        expect(onValidateResult).toEqual(<ValueHostValidationState>{
            status: ValidationStatus.Invalid,
            isValid: false,
            doNotSave: true,
            issuesFound: [neverMatchIssueFound],
            asyncProcessing: false,
            corrected: false
        });

        vh.getValidator(NeverMatchesConditionType)?.setEnabled(false);
        vh.getValidator(AlwaysMatchesConditionType)?.setEnabled(true);

        snapshot = vm.validate();
        expect(snapshot).toEqual(<ValidationState>{
            isValid: true,
            doNotSave: false,
            issuesFound: null,
            asyncProcessing: false
        });
        expect(onValidateResult).toEqual(<ValueHostValidationState>{
            status: ValidationStatus.Valid,
            isValid: true,
            doNotSave: false,
            issuesFound: null,
            asyncProcessing: false,
            corrected: true
        });

        vh.setValue(10);    // without validation changes status=NeedsValidation and triggers callback
        expect(onValidateResult).toEqual(<ValueHostValidationState>{
            status: ValidationStatus.NeedsValidation,
            isValid: true,
            doNotSave: true,
            issuesFound: null,
            asyncProcessing: false,
            corrected: false
        });
    });        

});

class ThrowExceptionValidator extends Validator {
    constructor(valueHost: IValidatorsValueHostBase, config: ValidatorConfig)
    {
        super(valueHost as any, config);
    }
    public override validate(options?: ValidateOptions): ValidatorValidateResult {
        throw new Error('Always Throws');
    }
}
class TestValidatorFactory implements IValidatorFactory {
    public create(valueHost: IValidatorsValueHostBase, config: ValidatorConfig): IValidator {
        return new ThrowExceptionValidator(valueHost, config);
    }
    canCreate(config: ValidatorConfig): boolean {
        return true;
    }
}

describe('validate handles exception from custom Validator class', () => {

    test('Expect an exception from the custom Validator to be logged and cause ValidatorsValueHostBase.Validator result to be Undetermined', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        setup.services.validatorFactory = new TestValidatorFactory();
        let logger = setup.services.loggerService as CapturingLogger;
        logger.minLevel = LoggingLevel.Info;
        expect(() => setup.valueHost.validate()).not.toThrow();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Undetermined);
        // 2 log entries: Error level exception and Info Level validation result
        expect(logger.findMessage('Always Throws', LoggingLevel.Error, LoggingCategory.Exception)).toBeTruthy();
        expect(logger.findMessage('Validation result', LoggingLevel.Info, LoggingCategory.Result)).toBeTruthy();
    });
});

function testValidateFunctionWithPromise(
    validatorConfigs: Array<Partial<ValidatorConfig>> | null,
    onValidationStateChanged: ValueHostValidationStateChangedHandler,
    onValueHostInstanceStateChanged?: ValueHostInstanceStateChangedHandler,
    validationGroup?: string | undefined): {
        services: IValidationServices,
        vm: IValidationManager,
        vh: TestValidatorsValueHost,
        promises: Array<Promise<ValidatorValidateResult>>
    } {
    let vhd1: ValidatorsValueHostBaseConfig = {
        name: 'Field1',
        label: 'Field 1',
        valueHostType: TestValueHostType,
        validatorConfigs: finishPartialValidatorConfigs(validatorConfigs ?? null)
    };
    let services = new ValidationServices();
    supportTestValueHostInServices(services);
    services.cultureService.activeCultureId = 'en';
    services.conditionFactory = new ConditionFactory();
    services.loggerService = new CapturingLogger();
    registerTestingOnlyConditions(services.conditionFactory as ConditionFactory);
    services.dataTypeComparerService = new DataTypeComparerService();
    services.dataTypeConverterService = new DataTypeConverterService();
    services.dataTypeFormatterService = new DataTypeFormatterService();
    services.dataTypeIdentifierService = new DataTypeIdentifierService();
    services.autoGenerateDataTypeCheckService = new AutoGenerateDataTypeCheckService();
    services.autoGenerateDataTypeCheckService.enabled = false;
    services.messageTokenResolverService = new MessageTokenResolverService();
    let vm = new ValidationManager({
        services: services,
        valueHostConfigs: [],
        onValueHostValidationStateChanged: onValidationStateChanged,
        onValueHostInstanceStateChanged: onValueHostInstanceStateChanged
    });
    let vh = vm.addValueHost(vhd1, null) as TestValidatorsValueHost;

    // let setup = SetupValidatorsValueHostBaseForValidate(validatorConfigs, inputValueState);
    // setup.validationManager.onValueHostValidationStateChanged = onValidationStateChanged;

    let vrDetails: ValueHostValidateResult | null = null;
    expect(() => vrDetails = vh.validate({ group: validationGroup })).not.toThrow();
    expect(vrDetails).not.toBeNull();
    expect(vrDetails!.pending).not.toBeNull();
    return {
        services: services,
        vm: vm,
        vh: vh,
        promises: vrDetails!.pending!
    };
}
async function testOnePendingResult(
    pending: Promise<ValidatorValidateResult>,
    expectedValidatorValidateResult: ValidatorValidateResult) {
    let asyncResult = await pending;

    expect(asyncResult.conditionEvaluateResult).toBe(expectedValidatorValidateResult.conditionEvaluateResult);
}
function validateWithAsyncConditions(
    conditionEvaluateResult: ConditionEvaluateResult,
    // one entry per promise expected, in the order of the promises
    expectedValidatorValidateResults: Array<ValidatorValidateResult>,
    // one entry per expected OnValueHostValidate, in the order expected
    expectedValidateResults: Array<ValueHostValidateResult>,
    done: jest.DoneCallback,
    // place this before the auto generated async condition
    before?: ValidatorConfig | null,
    // place this after the auto generated async condition
    after?: ValidatorConfig | null,
    doneAfterStateChangeCount?: number): void {
    let ivConfigs: Array<Partial<ValidatorConfig>> = [];
    if (before)
        ivConfigs.push(before);
    ivConfigs.push({
        conditionConfig: null,
        conditionCreator: (requester) =>
            new ConditionWithPromiseTester(
                conditionEvaluateResult, 0
            )
    });
    if (after)
        ivConfigs.push(after);

    let doneTime = false;
    let handlerCount = 0;
    let onValidateHandler: ValueHostValidationStateChangedHandler =
        (valueHost: IValidatableValueHostBase, snapshot: ValueHostValidationState) => {
            let vm = (valueHost as TestValidatorsValueHost).valueHostsManager as IValidationManager;
            let evr = expectedValidateResults[handlerCount];
            expect(snapshot.isValid).toBe(evr.status !== ValidationStatus.Invalid);
            expect(snapshot.issuesFound).toEqual(evr.issuesFound);
            if (evr.pending) {
                expect(snapshot.asyncProcessing).toBe(true);
                expect(valueHost.asyncProcessing).toBe(true);
                expect(vm.asyncProcessing).toBe(true);
            }
            else {
                expect(snapshot.asyncProcessing).toBe(false);
                expect(valueHost.asyncProcessing).toBe(false);
                expect(vm.asyncProcessing).toBe(false);
            }
            handlerCount++;
            if (doneTime) {
                expect(vm.doNotSave).toBe(evr.status === ValidationStatus.Invalid);
                done();
            }
            else
                expect(vm.doNotSave).toBe(true);
        };
    let stateChangeCounter = 0;
    let onStateChangedHandler: ValueHostInstanceStateChangedHandler =
        (valueHost: IValueHost, stateToRetain: ValueHostInstanceState) => {
            stateChangeCounter++;
            if (stateChangeCounter === doneAfterStateChangeCount)
                done();
        };

    let setup = testValidateFunctionWithPromise(ivConfigs, onValidateHandler, onStateChangedHandler);
    expect(setup.promises.length).toBe(expectedValidatorValidateResults.length);

    for (let i = 0; i < setup.promises.length; i++)
        testOnePendingResult(setup.promises[i], expectedValidatorValidateResults[i]);
    // we are awaiting a callback to onValueHostValidationStateChanged to finish,
    // but only if the expected result is Invalid
    doneTime = true;
    expect(setup.vm.doNotSave).toBe(true); // because of Async, regardless of ValidationStatus
}
describe('validate with async Conditions', () => {
    test('With 1 Condition that returns a promise evaluating as Match is ValidatorResult.Valid, IssuesFound = null',
        (done) => {
            validateWithAsyncConditions(ConditionEvaluateResult.Match,
                [{
                    conditionEvaluateResult: ConditionEvaluateResult.Match,
                    issueFound: null
                }],
                [
                    { // onValueHostValidate prior to promise
                        status: ValidationStatus.Undetermined,
                        issuesFound: null,
                        pending: [<any>{}]
                    },
                    {   // after promise
                        status: ValidationStatus.Valid,
                        issuesFound: null,

                    }
                ],
                done, null, null,
                2); // 2 onstatechanged to invoke done()
        },
        1500);  // shortened timeout
    test('With 1 Condition that returns a promise evaluating as NoMatch is ValidatorResult.Invalid, IssuesFound assigned',
        (done) => {
            let issueFound: IssueFound = {
                errorCode: 'TEST',
                errorMessage: 'Local',
                severity: ValidationSeverity.Error,
                valueHostName: 'Field1',
                summaryMessage: 'Summary'
            };

            validateWithAsyncConditions(ConditionEvaluateResult.NoMatch,
                [{
                    conditionEvaluateResult: ConditionEvaluateResult.NoMatch,
                    issueFound: issueFound
                }],
                [{  // onValueHostValidate prior to promise
                    status: ValidationStatus.Undetermined,
                    issuesFound: null,
                    pending: [<any>{}]
                },
                {   // after promise
                    status: ValidationStatus.Invalid,
                    issuesFound: [issueFound]
                }],
                done);
        },
        1500);  // shortened timeout
    test('With 1 Condition that returns a promise evaluating as Undetermined is ValidatorResult.Undetermined, IssuesFound = null',
        (done) => {
            validateWithAsyncConditions(ConditionEvaluateResult.Undetermined,
                [{
                    conditionEvaluateResult: ConditionEvaluateResult.Undetermined,
                    issueFound: null
                }],
                [{
                    status: ValidationStatus.Undetermined,
                    issuesFound: null,
                    pending: [<any>{}]
                }],
                done, null, null,
                2); // onstatechanges to invoke done()
        },
        1500);  // shortened timeout
    test('With 2 Conditions, first is Match, second is async that returns a promise evaluating as Match is ValidatorResult.Valid, IssuesFound = null',
        (done) => {
            validateWithAsyncConditions(ConditionEvaluateResult.Match,
                [{
                    conditionEvaluateResult: ConditionEvaluateResult.Match,
                    issueFound: null
                }],
                [{
                    status: ValidationStatus.Valid,
                    issuesFound: null,
                    pending: [<any>{}]
                }],
                done,
                <ValidatorConfig>{
                    conditionConfig: {
                        conditionType: AlwaysMatchesConditionType
                    },
                    errorMessage: 'Always',
                }, null,
                2); // 2 onstatechanges to invoke done()
        },
        1500);  // shortened timeout
    test('With 2 Conditions, second is Match, first is async that returns a promise evaluating as Match is ValidatorResult.Valid, IssuesFound = null',
        (done) => {
            validateWithAsyncConditions(ConditionEvaluateResult.Match,
                [{
                    conditionEvaluateResult: ConditionEvaluateResult.Match,
                    issueFound: null
                }],
                [{
                    status: ValidationStatus.Valid,
                    issuesFound: null,
                    pending: [<any>{}]
                }],
                done,
                null,
                <ValidatorConfig>{
                    conditionConfig: {
                        conditionType: AlwaysMatchesConditionType
                    },
                    errorMessage: 'Always',
                },
                2); // 2 onstatechanges to invoke done()
        },
        1500);  // shortened timeout
    test('With 2 Conditions, first is NoMatch, second is async that returns a promise evaluating as Match is ValidatorResult.Valid, IssuesFound = null, result is Invalid with 1 issuefound',
        (done) => {
            let issueFound: IssueFound = {
                errorCode: NeverMatchesConditionType,
                errorMessage: 'Never',
                severity: ValidationSeverity.Error,
                valueHostName: 'Field1',
                summaryMessage: 'Summary'
            };
            validateWithAsyncConditions(ConditionEvaluateResult.Match,
                [{
                    conditionEvaluateResult: ConditionEvaluateResult.Match,
                    issueFound: null
                }],
                [
                    // Despite the async returning, it doesn't change the result
                    // so there is only one call to OnValueHostValidate
                    {
                        status: ValidationStatus.Invalid,
                        issuesFound: [issueFound],
                        pending: [<any>{}]
                    }],
                done,
                <ValidatorConfig>{
                    conditionConfig: {
                        conditionType: NeverMatchesConditionType
                    },
                    errorMessage: 'Never',
                },
                null,
                2); // to catch the final promise communication which doesn't use OnValidate
        },
        1500);  // shortened timeout
    test('With 2 Conditions, first is NoMatch, second is async that returns a promise evaluating as NoMatch, result is Invalid with 2 issues found',
        (done) => {
            let issueFoundFromNever: IssueFound = {
                errorCode: NeverMatchesConditionType,
                errorMessage: 'Never',
                severity: ValidationSeverity.Error,
                valueHostName: 'Field1',
                summaryMessage: 'Never Summary'
            };
            let issueFoundFromPromise: IssueFound = {
                errorCode: 'TEST',
                errorMessage: 'Local',
                severity: ValidationSeverity.Error,
                valueHostName: 'Field1',
                summaryMessage: 'Summary'
            };
            validateWithAsyncConditions(ConditionEvaluateResult.NoMatch,
                [{
                    conditionEvaluateResult: ConditionEvaluateResult.NoMatch,
                    issueFound: issueFoundFromPromise
                }],
                [
                    {
                        status: ValidationStatus.Invalid,
                        issuesFound: [issueFoundFromNever],
                        pending: [<any>{}]
                    },
                    {
                        status: ValidationStatus.Invalid,
                        issuesFound: [issueFoundFromNever, issueFoundFromPromise],
                    }],
                done,
                <ValidatorConfig>{
                    conditionConfig: {
                        conditionType: NeverMatchesConditionType
                    },
                    errorMessage: 'Never',
                    summaryMessage: 'Never Summary'
                });
        },
        1500);  // shortened timeout

    test('With 2 Conditions, second is NoMatch, first is async that returns a promise evaluating as NoMatch, result is Invalid with 2 issues found',
        (done) => {
            let issueFoundFromNever: IssueFound = {
                errorCode: NeverMatchesConditionType,
                errorMessage: 'Never',
                severity: ValidationSeverity.Error,
                valueHostName: 'Field1',
                summaryMessage: 'Never Summary'
            };
            let issueFoundFromPromise: IssueFound = {
                errorCode: 'TEST',
                errorMessage: 'Local',
                severity: ValidationSeverity.Error,
                valueHostName: 'Field1',
                summaryMessage: 'Summary'
            };
            validateWithAsyncConditions(ConditionEvaluateResult.NoMatch,
                [{
                    conditionEvaluateResult: ConditionEvaluateResult.NoMatch,
                    issueFound: issueFoundFromPromise
                }],
                [
                    {
                        status: ValidationStatus.Invalid,
                        issuesFound: [issueFoundFromNever],
                        pending: [<any>{}]
                    },
                    {
                        status: ValidationStatus.Invalid,
                        issuesFound: [issueFoundFromNever, issueFoundFromPromise],
                    }],
                done,
                null, // before not assigned
                <ValidatorConfig>{
                    conditionConfig: {
                        conditionType: NeverMatchesConditionType
                    },
                    errorMessage: 'Never',
                    summaryMessage: 'Never Summary'
                });
        },
        1500);  // shortened timeout    
    test('With 2 Conditions, both are async and both return a promise of Match. 1 OnValidate call. 2 OnValueHostInstanceStateChanges',
        (done) => {
            validateWithAsyncConditions(ConditionEvaluateResult.Match,
                [{
                    conditionEvaluateResult: ConditionEvaluateResult.Match,
                    issueFound: null
                },
                {
                    conditionEvaluateResult: ConditionEvaluateResult.Match,
                    issueFound: null
                }],
                [{
                    status: ValidationStatus.Undetermined,
                    issuesFound: null,
                    pending: [<any>{}, <any>{}]
                }],
                done,
                null,
                <ValidatorConfig>{
                    conditionConfig: null,
                    conditionCreator: (requester) =>
                        new ConditionWithPromiseTester(
                            ConditionEvaluateResult.Match, 0
                        ),
                    errorMessage: 'Second'
                },
                2); // state change count
        },
        1500);  // shortened timeout   

    test('With 1 Condition that whose promise gets rejected doesnt change validation results',
        (done) => {
            let vds: ValidatorConfig = {
                conditionConfig: null,
                conditionCreator: (requester) => {
                    return <ICondition>{
                        category: ConditionCategory.Undetermined,
                        conditionType: 'TEST',
                        evaluate: (valueHost: IValueHost | null,
                            valueHostResolver: IValueHostResolver) => {
                            let promise = new Promise<ConditionEvaluateResult>(
                                (resolve, reject) => {
                                    reject('REJECTED ERROR');
                                }
                            );
                            return promise;
                        }
                    };
                },
                errorMessage: 'Error'
            };
            // expect the sync process does nothing and thus doesn't call onValidate,
            // but it does update the state for asyncProcessing=true
            // Then when the promise completes, it also doesn't call onValidate
            // but it does update the state for asyncProcessing=false
            let onValidateHandler: ValueHostValidationStateChangedHandler =
                (vh, vr) => {
                    //         fail();
                };
            let statecounter = 0;
            let onStateChangedHandler: ValueHostInstanceStateChangedHandler =
                (vh, stateToRetain) => {
                    statecounter++;
                    if (statecounter === 2) {
                        let logger = setup.services.loggerService as CapturingLogger;
                        expect(logger.findMessage('REJECTED ERROR')).toBeTruthy();
                        done();
                    }
                };
            let setup = testValidateFunctionWithPromise([vds], onValidateHandler, onStateChangedHandler);
            expect(setup.promises.length).toBe(1);

        },
        1500);  // shortened timeout    
});

// clearValidation(): void
describe('clearValidation', () => {
    test('After validate, Ensure no exceptions and the state is NotAttempted with IssuesFound = null', () => {
        let ivConfig: ValidatorConfig = {
            conditionConfig: { conditionType: IsUndeterminedConditionType },
            errorMessage: ''
        };
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            ivConfig
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);

        setup.valueHost.validate();
        let result: boolean | null = null;
        expect(() => result = setup.valueHost.clearValidation()).not.toThrow();
        expect(result).toBe(true);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NotAttempted);
        expect(setup.valueHost.getIssueFound(IsUndeterminedConditionType)).toBeNull();

        let stateChanges = setup.validationManager.getHostStateChanges();
        expect(stateChanges).not.toBeNull();
        expect(stateChanges.length).toBe(2);
        let expectedChanges: Array<ValidatorsValueHostBaseInstanceState> = [
            {
                name: 'Field1',
                status: ValidationStatus.Undetermined,
                issuesFound: null,
                value: undefined
            },
            {
                name: 'Field1',
                status: ValidationStatus.NotAttempted,
                issuesFound: null,
                value: undefined
            },
        ];
        expect(stateChanges).toEqual(expectedChanges);

    });
    test('Without calling validate, Ensure no exceptions and the state is NotAttempted with IssuesFound = null', () => {
        let ivConfig: ValidatorConfig = {
            conditionConfig: { conditionType: IsUndeterminedConditionType },
            errorMessage: ''
        };
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            ivConfig
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);

        let result: boolean | null = null;
        expect(() => result = setup.valueHost.clearValidation()).not.toThrow();
        expect(result).toBe(false);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NotAttempted);
        expect(setup.valueHost.getIssueFound(IsUndeterminedConditionType)).toBeNull();
        let stateChanges = setup.validationManager.getHostStateChanges();
        expect(stateChanges).not.toBeNull();
        expect(stateChanges.length).toBe(0);

    });
    test('With prior state reflecting a validation issue, Ensure no exceptions and the state is NotAttempted with IssuesFound = null', () => {
        let ivConfig: ValidatorConfig = {
            conditionConfig: { conditionType: NeverMatchesConditionType },
            errorMessage: ''
        };
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            ivConfig
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {
            name: 'Field1',
            status: ValidationStatus.Invalid,
            issuesFound: []
        };
        state.issuesFound!.push(createIssueFound(NeverMatchesConditionType));

        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);

        let result: boolean | null = null;
        expect(() => result = setup.valueHost.clearValidation()).not.toThrow();
        expect(result).toBe(true);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NotAttempted);
        expect(setup.valueHost.getIssueFound(NeverMatchesConditionType)).toBeNull();

    });
    test('Option.group matches clears', () => {
        let ivConfig: ValidatorConfig = {
            conditionConfig: { conditionType: NeverMatchesConditionType },
            errorMessage: ''
        };
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            ivConfig
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {
            name: 'Field1',
            status: ValidationStatus.Invalid,
            issuesFound: []
        };
        state.issuesFound!.push(createIssueFound(NeverMatchesConditionType));

        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        let modifier = setup.validationManager.startModifying() as TestValueHostForValidationManagerConfigModifier;
        modifier.testValueHost('Field1', null, { group: 'GROUPA' });
        modifier.apply();
        setup.valueHost = setup.validationManager.getValueHost('Field1') as TestValidatorsValueHost;    // because apply discards the previous instance

        let result: boolean | null = null;
        expect(() => result = setup.valueHost.clearValidation({ group: 'GROUPA'})).not.toThrow();
        expect(result).toBe(true);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NotAttempted);
        expect(setup.valueHost.getIssueFound(NeverMatchesConditionType)).toBeNull();

    });
    test('Option.group does not match, nothing cleared', () => {
        let ivConfig: ValidatorConfig = {
            conditionConfig: { conditionType: NeverMatchesConditionType },
            errorMessage: ''
        };
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            ivConfig
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {
            name: 'Field1',
            status: ValidationStatus.Invalid,
            issuesFound: []
        };
        state.issuesFound!.push(createIssueFound(NeverMatchesConditionType));

        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        let modifier = setup.validationManager.startModifying() as TestValueHostForValidationManagerConfigModifier;
        modifier.testValueHost('Field1', null, { group: 'GROUPA' });
        modifier.apply();
        setup.valueHost = setup.validationManager.getValueHost('Field1') as TestValidatorsValueHost;   // because modifier has clobbered the existing instance

        let result: boolean | null = null;
        expect(() => result = setup.valueHost.clearValidation({ group: 'GROUPB'})).not.toThrow();
        expect(result).toBe(false);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Invalid);
        expect(setup.valueHost.getIssueFound(NeverMatchesConditionType)).not.toBeNull();

    });    
    test('Without calling validate but with BusinessLogicError (Error), Ensure the state discards BusinessLogicError after clear', () => {
        let setup = setupValidatorsValueHostBaseForValidate([], {});
        setup.valueHost.setBusinessLogicError({
            errorMessage: 'ERROR',
            severity: ValidationSeverity.Error
        });

        let result: boolean | null = null;
        expect(() => result = setup.valueHost.clearValidation()).not.toThrow();
        expect(result).toBe(true);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NotAttempted);
        let stateChanges = setup.validationManager.getHostStateChanges();
        expect(stateChanges).not.toBeNull();
        expect(stateChanges.length).toBe(2);
        let expectedChanges: Array<ValidatorsValueHostBaseInstanceState> = [
            {
                name: 'Field1',
                status: ValidationStatus.NotAttempted,
                issuesFound: null,
                value: undefined,
                businessLogicErrors: [
                    {
                        errorMessage: 'ERROR',
                        severity: ValidationSeverity.Error
                    }
                ]
            },
            {
                name: 'Field1',
                status: ValidationStatus.NotAttempted,
                issuesFound: null,
                value: undefined
            },
        ];
        expect(stateChanges).toEqual(expectedChanges);
    });
    test('onValueHostValidationStateChanged called', () => {
        let onValidateResult: ValueHostValidationState | null = null;

        let vmConfig: ValidationManagerConfig = {
            services: createValidationServicesForTesting(),
            valueHostConfigs: [],
            onValueHostValidationStateChanged: (vh, vr) => {
                onValidateResult = vr;
            }
        };
        supportTestValueHostInServices(vmConfig.services);
        let vm = new ValidationManager(vmConfig);
        let vh = vm.addValueHost(<ValidatorsValueHostBaseConfig>{
            valueHostType: TestValueHostType,
            name: 'Field1',
            validatorConfigs: [
                {
                    conditionConfig: {
                        conditionType: NeverMatchesConditionType
                    },
                    errorMessage: 'Error'
                }
            ]
        }, null) as TestValidatorsValueHost;

        let neverMatchIssueFound: IssueFound = {
            errorCode: NeverMatchesConditionType,
            errorMessage: 'Error',
            summaryMessage: 'Error',
            valueHostName: 'Field1',
            severity: ValidationSeverity.Error
        };

        let snapshot = vm.validate({ skipCallback: true }); // ensure we have an invalid state without business logic
        expect(snapshot).toEqual(<ValidationState>{
            isValid: false,
            doNotSave: true,
            issuesFound: [neverMatchIssueFound],
            asyncProcessing: false
        });

        let result: boolean | null = null;
        expect(() => result = vh.clearValidation()).not.toThrow();

        expect(onValidateResult).toEqual(<ValueHostValidationState>{
            issuesFound: null,
            isValid: true,
            doNotSave: false,
            asyncProcessing: false,
            status: ValidationStatus.NotAttempted,
            corrected: false
        });
    });        

    test('onValueHostValidationStateChanged not called when options.skipCallback = true', () => {
        let onValidateResult: ValueHostValidationState | null = null;

        let vmConfig: ValidationManagerConfig = {
            services: createValidationServicesForTesting(),
            valueHostConfigs: [],
            onValueHostValidationStateChanged: (vh, vr) => {
                onValidateResult = vr;
            }
        };
        supportTestValueHostInServices(vmConfig.services);
        let vm = new ValidationManager(vmConfig);
        let vh = vm.addValueHost(<ValidatorsValueHostBaseConfig>{
            valueHostType: TestValueHostType,
            name: 'Field1',
            validatorConfigs: [
                {
                    conditionConfig: {
                        conditionType: NeverMatchesConditionType
                    },
                    errorMessage: 'Error'
                }
            ]
        }, null) as TestValidatorsValueHost;

        let neverMatchIssueFound: IssueFound = {
            errorCode: NeverMatchesConditionType,
            errorMessage: 'Error',
            summaryMessage: 'Error',
            valueHostName: 'Field1',
            severity: ValidationSeverity.Error
        };

        let snapshot = vm.validate({ skipCallback: true }); // ensure we have an invalid state without business logic
        expect(snapshot).toEqual(<ValidationState>{
            isValid: false,
            doNotSave: true,
            issuesFound: [neverMatchIssueFound],
            asyncProcessing: false
        });

        let result: boolean | null = null;
        expect(() => result = vh.clearValidation({ skipCallback: true })).not.toThrow();

        expect(onValidateResult).toBeNull();
    });        
});


describe('ValidatorsValueHostBase.clearBusinessLogicErrors', () => {
    
    test('With existing validator using the same errorcode as businesslogicerror and the validator was previously valid, add an issueFound and not a businesslogicerror', () => {
        let onValidateResult: ValueHostValidationState | null = null;

        let vmConfig: ValidationManagerConfig = {
            services: createValidationServicesForTesting(),
            valueHostConfigs: [],
            onValueHostValidationStateChanged: (vh, vr) => {
                onValidateResult = vr;
            }
        };
        supportTestValueHostInServices(vmConfig.services);
        let vm = new ValidationManager(vmConfig);
        let vh = vm.addValueHost(<ValidatorsValueHostBaseConfig>{
            valueHostType: TestValueHostType,
            name: 'Field1',
            validatorConfigs: [
                {
                    conditionConfig: {
                        conditionType: UserSuppliedResultConditionType,
                        result: ConditionEvaluateResult.Match,
                        category: ConditionCategory.Contents
                    },
                    errorMessage: 'TOBEREPLACED Error message',
                    errorCode: 'TOBEREPLACED',
                },
                {
                    conditionConfig: {
                        conditionType: NeverMatchesConditionType,
                    },
                    errorMessage: 'Never match',
                    errorCode: 'WILLNOTBEREPLACED'
                }
            ]
        }, null) as TestValidatorsValueHost;

        let toBeReplacedIssueFound: IssueFound = {
            errorCode: 'TOBEREPLACED',
            errorMessage: 'TOBEREPLACED Error message',
            summaryMessage: 'TOBEREPLACED Error message',
            valueHostName: 'Field1',
            severity: ValidationSeverity.Error
        };
        let neverMatchIssueFound: IssueFound = {
            errorCode: 'WILLNOTBEREPLACED',
            errorMessage: 'Never match',
            summaryMessage: 'Never match',
            valueHostName: 'Field1',
            severity: ValidationSeverity.Error
        };        

        vm.validate(); 
        expect(vh.getIssuesFound()).toEqual([neverMatchIssueFound]);        

        let result = vh.setBusinessLogicError({
            errorCode: 'TOBEREPLACED',
            errorMessage: 'Business Logic error message',
//            severity: ValidationSeverity.Error will use Severe for Category=Require
        });
        expect(result).toBe(true);
        expect(vh.getIssuesFound()).toEqual([neverMatchIssueFound, toBeReplacedIssueFound]);        
        expect(onValidateResult).toEqual(<ValueHostValidationState>{
            isValid: false,
            issuesFound: [neverMatchIssueFound, toBeReplacedIssueFound],
            doNotSave: true,
            asyncProcessing: false,
            status: ValidationStatus.Invalid,
            corrected: false
        });

    });    
    test('With existing validator using the same errorcode as businesslogicerror and the validator was previously invalid, replace that validators IssueFound and do not add the businesslogicerror', () => {
        let onValidateResult: ValueHostValidationState | null = null;

        let vmConfig: ValidationManagerConfig = {
            services: createValidationServicesForTesting(),
            valueHostConfigs: [],
            onValueHostValidationStateChanged: (vh, vr) => {
                onValidateResult = vr;
            }
        };
        supportTestValueHostInServices(vmConfig.services);
        let vm = new ValidationManager(vmConfig);
        let vh = vm.addValueHost(<ValidatorsValueHostBaseConfig>{
            valueHostType: TestValueHostType,
            name: 'Field1',
            validatorConfigs: [
                {
                    conditionConfig: {
                        conditionType: UserSuppliedResultConditionType,
                        result: ConditionEvaluateResult.NoMatch,
                        category: ConditionCategory.Contents
                    },
                    errorMessage: 'TOBEREPLACED Error message',
                    errorCode: 'TOBEREPLACED',
                    severity: ValidationSeverity.Warning   // helps notice the issue was replaced when we later change the severity
                },
                {
                    conditionConfig: {
                        conditionType: NeverMatchesConditionType,
                    },
                    errorMessage: 'Never match',
                    errorCode: 'WILLNOTBEREPLACED'
                }
            ]
        }, null) as TestValidatorsValueHost;

        let strLenIssueFound: IssueFound = {
            errorCode: 'TOBEREPLACED',
            errorMessage: 'TOBEREPLACED Error message',
            summaryMessage: 'TOBEREPLACED Error message',
            valueHostName: 'Field1',
            severity: ValidationSeverity.Warning
        };
        let neverMatchIssueFound: IssueFound = {
            errorCode: 'WILLNOTBEREPLACED',
            errorMessage: 'Never match',
            summaryMessage: 'Never match',
            valueHostName: 'Field1',
            severity: ValidationSeverity.Error
        };        
        vm.validate(); 
        expect(vh.getIssuesFound()).toEqual([strLenIssueFound, neverMatchIssueFound]);        

        let result = vh.setBusinessLogicError({
            errorCode: 'TOBEREPLACED',
            errorMessage: 'Business Logic error message',
            severity: ValidationSeverity.Error // by declaring, it overrides the original and is useful here to see the issuefound changed
        });
        expect(result).toBe(true);
        strLenIssueFound.severity = ValidationSeverity.Error;
        expect(vh.getIssuesFound()).toEqual([strLenIssueFound, neverMatchIssueFound]);        
        expect(onValidateResult).toEqual(<ValueHostValidationState>{
            isValid: false,
            issuesFound: [strLenIssueFound, neverMatchIssueFound],
            doNotSave: true,
            asyncProcessing: false,
            status: ValidationStatus.Invalid,
            corrected: false
        });

    });        
});


// getIssueFound(validatorConfig: ValidatorConfig): IssueFound | null
describe('ValidatorsValueHostBase.getIssueFound', () => {
    test('Without Validators is null', () => {
        let setup = testValidateFunctionIsNull(null, null);
        let issueFound: IssueFound | null = null;
        expect(() => issueFound = setup.valueHost.getIssueFound(null!)).not.toThrow();
        expect(issueFound).toBeNull();
    });
    test('With 1 Condition evaluating as Match is ValidatorResult.Valid, IssuesFound = null', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let setup = testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Valid, null);
        let issueFound: IssueFound | null = null;
        expect(() => issueFound = setup.valueHost.getIssueFound(AlwaysMatchesConditionType)).not.toThrow();
        expect(issueFound).toBeNull();
    });
    test('With 1 Condition evaluating as NoMatch is ValidatorResult.Invalid, IssuesFound = 1', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let issuesFound: Array<IssueFound> = [];
        issuesFound.push(createIssueFound(NeverMatchesConditionType));
        let setup = testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Invalid, issuesFound);
        let issueFound: IssueFound | null = null;
        expect(() => issueFound = setup.valueHost.getIssueFound(NeverMatchesConditionType)).not.toThrow();
        expect(issueFound).not.toBeNull();
        expect(issuesFound.length).toBe(1);
        expect(issueFound).toEqual(issuesFound[0]);
    });
});

// getIssuesFound(): Array<IssueFound>
describe('ValidatorsValueHostBase.getIssuesFound', () => {
    test('Nothing to report returns null', () => {
        let setup = testValidateFunctionIsNull(null, null);
        let issuesFound: Array<IssueFound> | null = null;
        expect(() => issuesFound = setup.valueHost.getIssuesFound()).not.toThrow();
        expect(issuesFound).toBeNull();
    });
    test('2 issues exist. Both are returned in the order of the ValidationConfigs array.', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                },
                errorMessage: '1',
                summaryMessage: 'Summary1',
                severity: ValidationSeverity.Warning
            },
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType2
                },
                errorMessage: '2',
                summaryMessage: 'Summary2'
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {};
        let expectedIssuesFound: Array<IssueFound> = [];
        expectedIssuesFound.push(createIssueFound(NeverMatchesConditionType, ValidationSeverity.Warning, '1', 'Summary1'));
        expectedIssuesFound.push(createIssueFound(NeverMatchesConditionType2, ValidationSeverity.Error, '2', 'Summary2'));
        let setup = testValidateFunctionHasResult(ivConfigs, state, ValidationStatus.Invalid, expectedIssuesFound);
        let issuesToReport: Array<IssueFound> | null = null;
        expect(() => issuesToReport = setup.valueHost.getIssuesFound()).not.toThrow();
        expect(issuesToReport).not.toBeNull();
        let expected: Array<IssueFound> = [
            {
                valueHostName: 'Field1',
                errorCode: NeverMatchesConditionType,
                severity: ValidationSeverity.Warning,
                errorMessage: '1',
                summaryMessage: 'Summary1'
            },
            {
                valueHostName: 'Field1',
                errorCode: NeverMatchesConditionType2,
                severity: ValidationSeverity.Error,
                errorMessage: '2',
                summaryMessage: 'Summary2'
            }
        ];
        expect(issuesToReport).toEqual(expected);
    });

    test('1 Validation error, and has BusinessLogicError (Error) reports 2 entries with BusinessLogicError last', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                },
                errorMessage: 'Condition Error',
                summaryMessage: 'Summary Condition Error',
                severity: ValidationSeverity.Error
            },

        ];
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, {});
        setup.valueHost.setBusinessLogicError({
            errorMessage: 'BL_ERROR',
            // use the default         severity: ValidationSeverity.Error
        });
        let issuesFound: Array<IssueFound> | null = null;
        setup.valueHost.validate();
        expect(() => issuesFound = setup.valueHost.getIssuesFound()).not.toThrow();
        expect(issuesFound).not.toBeNull();

        let expected: Array<IssueFound> = [
            {
                valueHostName: 'Field1',
                errorCode: NeverMatchesConditionType,
                severity: ValidationSeverity.Error,
                errorMessage: 'Condition Error',
                summaryMessage: 'Summary Condition Error'
            },
            {
                valueHostName: 'Field1',
                errorCode: 'GENERATED_0',
                severity: ValidationSeverity.Error,
                errorMessage: 'BL_ERROR',
                summaryMessage: 'BL_ERROR'
            },
        ];
        expect(issuesFound).toEqual(expected);
    });
});

describe('setIssuesFound', () => {
    // Creates an array of ValidatorConfigs, with the number supplied the length of conditionTypes.
    // The conditionTypes are used in order.
    // The errorCodes are 'EC1', 'EC2', 'EC3', etc
    // 
    function generateVHConfig(conditionTypes: Array<string>, valueHostName: string = 'Field1'): ValidatorsValueHostBaseConfig
    {
        let configs: Array<ValidatorConfig> = [];
        let count = 1;
        for (let ct of conditionTypes) {
            let code = 'EC' + count;
            count++;
            configs.push(
                {
                    errorCode: code,
                    conditionConfig: {
                        conditionType: ct 
                    },
                    errorMessage: 'errorcode ' + code    // so we can show this error message is not used
                }
            );
        }
        let vhConfig: ValidatorsValueHostBaseConfig = {
            valueHostType: TestValueHostType,
            name: valueHostName,
            validatorConfigs: configs
        };    
        return vhConfig;
    }
    // Creates an array of IssueFound, with the number supplied the length of severities.
    // The severities are used in order.
    // The errorCodes are 'EC1', 'EC2', 'EC3', etc
    function generateIssuesFound(severities: Array<ValidationSeverity>, valueHostName: string = 'Field1'): Array<IssueFound>
    {
        let issuesFound: Array<IssueFound> = [];
        let count = 1;
        for (let s of severities) {
            let code = 'EC' + count;
            count++;
            issuesFound.push(
                {
                    errorCode: code,
                    severity: s,
                    valueHostName: valueHostName,
                    errorMessage: 'Message errorcode ' + code + ' from IssueFound',
                    summaryMessage: 'Summary errorcode ' + code + ' from IssueFound'                    
                }
            );
        }
        return issuesFound;
    }
    function setupForSetIssuesFound(vhConfig: Array<ValidatorsValueHostBaseConfig>, onValidatedCallback?: ValueHostValidationStateChangedHandler): ITestSetupConfig
    {
        let services = createValidationServicesForTesting();
        supportTestValueHostInServices(services);
        services.autoGenerateDataTypeCheckService.enabled = false;

        let vmConfig: ValidationManagerConfig = {
            services: services,
            valueHostConfigs: vhConfig,
            onValueHostValidationStateChanged : onValidatedCallback
        };
        let vm = new ValidationManager(vmConfig);
        let testItem = vm.getValueHost('Field1') as TestValidatorsValueHost;
        return {
            config: null!,  
            services: services,
            state: undefined!,
            validationManager: vm,
            valueHost: testItem
        };
    }

    function testSetIssuesFound(setup: ITestSetupConfig, issuesFoundToSet: Array<IssueFound>, expectedIssuesFoundToGet: Array<IssueFound> | null, expectedChanged: boolean = true,
        expectedValidationStatus: ValidationStatus = ValidationStatus.Invalid, behavior: SetIssuesFoundErrorCodeMissingBehavior = SetIssuesFoundErrorCodeMissingBehavior.Omit
    ): void
    {
        let testItem = setup.valueHost;
        let changed = false;
        expect(() => changed = testItem.setIssuesFound(issuesFoundToSet, behavior)).not.toThrow();
        expect(changed).toBe(expectedChanged);
        expect(testItem.validationStatus).toBe(expectedValidationStatus);
        let retrieved = testItem.getIssuesFound();
        if (expectedIssuesFoundToGet) {
            expect(retrieved).not.toBeNull();
            expect(retrieved).not.toBe(expectedIssuesFoundToGet); // list object is different
            expect(retrieved).toEqual(expectedIssuesFoundToGet); // but structure is the same        
        }
        else
            expect(retrieved).toBeNull();
    }
    function testMatchToGetIssuesFound(setup: ITestSetupConfig, expectedIssuesFoundToGet: Array<IssueFound>): void
    {
        let retrieved = setup.valueHost.getIssuesFound();
        expect(retrieved).not.toBeNull();
        expect(retrieved).toEqual(expectedIssuesFoundToGet); // but structure is the same        
    }
    function getExpectedIssueFoundFromValidator(issueIndex: number, valueHostName: string = 'Field1'): IssueFound
    {
        let ec = 'EC' + (issueIndex + 1);
        return <IssueFound> {
            errorCode: ec,
            errorMessage: 'errorcode ' + ec, // expected to match the one setup in vhConfig
            severity: ValidationSeverity.Error,
            valueHostName: valueHostName,
            summaryMessage: 'errorcode ' + ec, // expected to match the one setup in vhConfig
        };        
    }
    test('With 2 validators on the VH and nothing validated, provide an IssueFound for each. Expect ValidationStatus=Invalid and both IssuesFound returned verbatim from getIssuesFound()', () => {
        let vhConfig = generateVHConfig([AlwaysMatchesConditionType, AlwaysMatchesConditionType]);
        let setup = setupForSetIssuesFound([vhConfig]);
        let issuesFound = generateIssuesFound([ValidationSeverity.Error, ValidationSeverity.Error]);
        testSetIssuesFound(setup, issuesFound, issuesFound, true, ValidationStatus.Invalid);
    });
    test('One existing validation error gets replaced', () => {
        let vhConfig = generateVHConfig([NeverMatchesConditionType]);
        let setup = setupForSetIssuesFound([vhConfig]);
        setup.valueHost.validate();
        
        let issuesFound = generateIssuesFound([ValidationSeverity.Error]);
        testSetIssuesFound(setup, issuesFound, issuesFound, true, ValidationStatus.Invalid);
    });

    test('IssueFound has different errorCode from validators and behavior=Keep includes IssueFound', () => {
        let vhConfig = generateVHConfig([NeverMatchesConditionType]);
        let setup = setupForSetIssuesFound([vhConfig]);
        setup.valueHost.validate();
        
        let issuesFound = generateIssuesFound([ValidationSeverity.Error]);
        issuesFound[0].errorCode = 'Unknown';
        let expectedIssueFound = getExpectedIssueFoundFromValidator(0);
        testSetIssuesFound(setup, issuesFound, [expectedIssueFound, issuesFound[0] ], true, ValidationStatus.Invalid, SetIssuesFoundErrorCodeMissingBehavior.Keep);       
    });

    test('IssueFound has different errorCode from validators and behavior=Omit omits IssueFound and makes no changes', () => {
        let vhConfig = generateVHConfig([NeverMatchesConditionType]);
        let setup = setupForSetIssuesFound([vhConfig]);
        setup.valueHost.validate();
        
        let issuesFound = generateIssuesFound([ValidationSeverity.Error]);
        issuesFound[0].errorCode = 'Unknown';
        let expectedIssueFound = getExpectedIssueFoundFromValidator(0);
        testSetIssuesFound(setup, issuesFound, [expectedIssueFound], false, ValidationStatus.Invalid, SetIssuesFoundErrorCodeMissingBehavior.Omit);     
    });

    test('Two IssuesFound, but one validator. One errorcode matches and replaces. The other has behavior=Omit. Result is IssuesFound has the first IssueFound only and changed = true', () => {
        let vhConfig = generateVHConfig([NeverMatchesConditionType]);
        let setup = setupForSetIssuesFound([vhConfig]);
        setup.valueHost.validate();
        
        let issuesFound = generateIssuesFound([ValidationSeverity.Error, ValidationSeverity.Error]);
        let issueFoundEC1 = issuesFound[0];
        issuesFound[1].errorCode = 'Unknown';
        testSetIssuesFound(setup, issuesFound, [issueFoundEC1], true, ValidationStatus.Invalid, SetIssuesFoundErrorCodeMissingBehavior.Omit);     
    });


    test('IssueFound that was added is gone after using validate on valid data.', () => {
        let vhConfig = generateVHConfig([AlwaysMatchesConditionType]);
        let setup = setupForSetIssuesFound([vhConfig]);
        let issuesFound = generateIssuesFound([ValidationSeverity.Error]);
        let testItem = setup.valueHost;
        testItem.setIssuesFound(issuesFound, SetIssuesFoundErrorCodeMissingBehavior.Keep);

        testItem.validate();
        expect(testItem.validationStatus).toBe(ValidationStatus.Valid);
        expect(testItem.getIssuesFound()).toBeNull();
    });
    test('IssueFound that was added is replaced after using validate on invalid data with the same validator errorcode.', () => {
        let vhConfig = generateVHConfig([NeverMatchesConditionType]);
        let setup = setupForSetIssuesFound([vhConfig]);
        let issuesFound = generateIssuesFound([ValidationSeverity.Error]);
        let testItem = setup.valueHost;
        testItem.setIssuesFound(issuesFound, SetIssuesFoundErrorCodeMissingBehavior.Keep);

        testItem.validate();
        expect(testItem.validationStatus).toBe(ValidationStatus.Invalid);
        const expectedIssueFound = getExpectedIssueFoundFromValidator(0);
        testMatchToGetIssuesFound(setup, [expectedIssueFound]);
    });
    test('1 issue found with Severity=Warn does not change ValidationState already at Valid', () => {
        let vhConfig = generateVHConfig([AlwaysMatchesConditionType]);
        let setup = setupForSetIssuesFound([vhConfig]);
        let issuesFound = generateIssuesFound([ValidationSeverity.Warning]);
        let testItem = setup.valueHost;
        testItem.validate();    // ValidationStatus is now Valid
        testItem.setIssuesFound(issuesFound, SetIssuesFoundErrorCodeMissingBehavior.Keep);
        expect(testItem.validationStatus).toBe(ValidationStatus.Valid);
    });    

    test('1 issue found with Severity=Warn does not change ValidationState already at Invalid', () => {
        let vhConfig = generateVHConfig([NeverMatchesConditionType]);
        let setup = setupForSetIssuesFound([vhConfig]);
        let issuesFound = generateIssuesFound([ValidationSeverity.Warning]);
        let testItem = setup.valueHost;
        testItem.validate();    // ValidationStatus is now Invalid
        testItem.setIssuesFound(issuesFound, SetIssuesFoundErrorCodeMissingBehavior.Keep);
        expect(testItem.validationStatus).toBe(ValidationStatus.Invalid);        
    });        
    test('null parameter throws', () => {
        let vhConfig = generateVHConfig([NeverMatchesConditionType]);
        let setup = setupForSetIssuesFound([vhConfig]);

        let testItem = setup.valueHost;
        expect(() => testItem.setIssuesFound(null!, SetIssuesFoundErrorCodeMissingBehavior.Keep)).toThrow(/issuesFound/);
    });
    test('IssueFound with null or undefined errorCode parameter throws', () => {
        let vhConfig = generateVHConfig([NeverMatchesConditionType]);
        let setup = setupForSetIssuesFound([vhConfig]);

        let testItem = setup.valueHost;
        expect(() => testItem.setIssuesFound([{
            errorCode: undefined!,
            errorMessage: 'does not matter',
            severity: ValidationSeverity.Error,
            valueHostName: 'Field1'
        }], SetIssuesFoundErrorCodeMissingBehavior.Keep)).toThrow(/needs an errorCode/);
        expect(() => testItem.setIssuesFound([{
            errorCode: null!,
            errorMessage: 'does not matter',
            severity: ValidationSeverity.Error,
            valueHostName: 'Field1'
        }], SetIssuesFoundErrorCodeMissingBehavior.Keep)).toThrow(/needs an errorCode/);        
    });    
    test('IssueFound with unsupported valueHostName makes no changes', () => {
        let vhConfig = generateVHConfig([NeverMatchesConditionType]);
        let setup = setupForSetIssuesFound([vhConfig]);

        let testItem = setup.valueHost;
        expect(testItem.setIssuesFound([{
            errorCode: 'EC',
            errorMessage: 'does not matter',
            severity: ValidationSeverity.Error,
            valueHostName: 'unknown'
        }], SetIssuesFoundErrorCodeMissingBehavior.Keep)).toBe(false);
 
    });        
    test('onValueHostValidationStateChanged called when IssueFound was applied', () => {
        let vhConfig = generateVHConfig([NeverMatchesConditionType]);
        let count = 0;
        let setup = setupForSetIssuesFound([vhConfig], (vh) => {
            count++;
        });
        setup.valueHost.validate();
        expect(count).toBe(1);
        
        let issuesFound = generateIssuesFound([ValidationSeverity.Error]);
        let testItem = setup.valueHost;
        testItem.setIssuesFound(issuesFound, SetIssuesFoundErrorCodeMissingBehavior.Keep);
        expect(count).toBe(2);
    });    
    test('onValueHostValidationStateChanged not when IssueFound was not applied', () => {
        let vhConfig = generateVHConfig([NeverMatchesConditionType]);
        let count = 0;
        let setup = setupForSetIssuesFound([vhConfig], (vh) => {
            count++;
        });
        setup.valueHost.validate();
        expect(count).toBe(1);
        
        let issuesFound = generateIssuesFound([ValidationSeverity.Error], 'Different Field');
        let testItem = setup.valueHost;
        testItem.setIssuesFound(issuesFound, SetIssuesFoundErrorCodeMissingBehavior.Keep);
        expect(count).toBe(1);
    });        
});

describe('ValidatorsValueHostBase.gatherValueHostNames', () => {
    test('Gets two ValueHostNames', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: <DataTypeCheckConditionConfig>{
                    conditionType: ConditionType.DataTypeCheck,
                    valueHostName: 'Field1'
                }
            },
            {
                conditionConfig: <RequireTextConditionConfig>{
                    conditionType: ConditionType.RequireText,
                    valueHostName: 'Field2'
                }
            }
        ];
        let state: Partial<ValidatorsValueHostBaseInstanceState> = {
        };
        let setup = setupValidatorsValueHostBaseForValidate(ivConfigs, state);
        let collection = new Set<ValueHostName>();
        expect(() => setup.valueHost.gatherValueHostNames(collection, setup.validationManager)).not.toThrow();
        expect(collection.size).toBe(2);
        expect(collection.has('Field1')).toBe(true);
        expect(collection.has('Field2')).toBe(true);
    });
});


describe('ValidatorsValueHostBase.otherValueHostChangedNotification and setValues triggering ValidationManager.notifyOtherValueHostsOfValueChange to call otherValueHostChangedNotification', () => {

    // field1 has an Equals condition compared to field2
    // field2 will always validate as NoMatch
    // field3 will always validate as NoMatch
    function setupWithThreeValueHosts(): {
        vm: IValidationManager,
        services: IValidationServices,
        field1: IValidatorsValueHostBase,
        field2: IValidatorsValueHostBase,
        field3: IValidatorsValueHostBase
    } {

        let vhConfigs: Array<ValidatorsValueHostBaseConfig> = [
            { // Refers to Field2. So validation on Field2 should force this to update
                valueHostType: TestValueHostType,
                name: 'Field1',
                label: 'Label1',
                validatorConfigs: [{
                    conditionConfig: <EqualToConditionConfig>{
                        conditionType: ConditionType.EqualTo,
                        secondValueHostName: 'Field2',
                        valueHostName: null
                    },
                    errorMessage: 'Field1 Error'
                }]
            },
            {
                valueHostType: TestValueHostType,
                name: 'Field2',
                label: 'Label2',
                validatorConfigs: [{
                    // emulate RequireText because the real condition needs Input Value
                    conditionConfig: <UserSuppliedResultConditionConfig>{
                        conditionType: UserSuppliedResultConditionType,
                        category: ConditionCategory.Require,
                        result: ConditionEvaluateResult.NoMatch,
                    },           
                    errorMessage: 'Field2 Error',
                    errorCode: 'RTFld2'
                }]
            },
            { // Value changes should not notify another
                valueHostType: TestValueHostType,
                name: 'Field3',
                label: 'Label3',

                validatorConfigs: [{
                    // emulate RequireText because the real condition needs Input Value
                    conditionConfig: <UserSuppliedResultConditionConfig>{
                        conditionType: UserSuppliedResultConditionType,
                        category: ConditionCategory.Require,
                        result: ConditionEvaluateResult.NoMatch,

                    },           
                    errorMessage: 'Field3 Error',
                    errorCode: 'RTFld3'
                }]                
            }
        ];
        let services = createValidationServicesForTesting();
        supportTestValueHostInServices(services);
        let cf = services.conditionFactory as ConditionFactory;
        cf.register<EqualToConditionConfig>(
            ConditionType.EqualTo, (config) => new EqualToCondition(config));
        let vm = new ValidationManager({ services: services, valueHostConfigs: vhConfigs });   // the real thing so we use real ValidatorsValueHostBases


        return {
            vm: vm,
            services: services,
            field1: vm.getValueHost('Field1') as IValidatorsValueHostBase,
            field2: vm.getValueHost('Field2') as IValidatorsValueHostBase,
            field3: vm.getValueHost('Field3') as IValidatorsValueHostBase
        };
    }
    test('No field previously validated or changed. Use Notification from field1 to field2 with revalidate = false. ValidationStatus should not change.', () => {
        let setup = setupWithThreeValueHosts();
        expect(() => setup.field1.otherValueHostChangedNotification(
            setup.field2.getName(), false)).not.toThrow();
        expect(setup.field1.validationStatus).toBe(ValidationStatus.NotAttempted);
        expect(setup.field2.validationStatus).toBe(ValidationStatus.NotAttempted);
        expect(setup.field3.validationStatus).toBe(ValidationStatus.NotAttempted);
    });
    test('No field previously validated or changed. Use Notification from field2 to field1 with revalidate = false. ValidationStatus should not change.', () => {
        let setup = setupWithThreeValueHosts();

        expect(() => setup.field2.otherValueHostChangedNotification(
            setup.field1.getName(), false)).not.toThrow();
        expect(setup.field1.validationStatus).toBe(ValidationStatus.NotAttempted);
        expect(setup.field2.validationStatus).toBe(ValidationStatus.NotAttempted);
        expect(setup.field3.validationStatus).toBe(ValidationStatus.NotAttempted);
    });
    test('Field1 previously validated and is Invalid. Field2 changed, revalidate = false. Field1.ValidationStatus => NeedsValidation.', () => {
        let setup = setupWithThreeValueHosts();
        setup.field1.setValue('ABC');   // Equal condition will fail
        setup.field2.setValue('BCD');  

        setup.field1.validate();       // field1 = invalid

        expect(() => setup.field1.otherValueHostChangedNotification(
            setup.field2.getName(), false)).not.toThrow();
        expect(setup.field1.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.field2.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.field3.validationStatus).toBe(ValidationStatus.NotAttempted);
    });
    test('Field1 previously validated and is Invalid. Field2 changed via setValue with validate=false. Field1.ValidationStatus => NeedsValidation.', () => {
        let setup = setupWithThreeValueHosts();
        setup.field1.setValue('ABC');   // Equal condiiton will fail
        setup.field2.setValue('BCD');

        setup.field1.validate();        // field1 = invalid

        setup.field2.setValue('ABC');  // will trigger OtherValueHostChangedNotification with revalidate=false
        expect(setup.field1.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.field2.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.field3.validationStatus).toBe(ValidationStatus.NotAttempted);
    });
    test('Field1 previously validated and is Invalid. Field2 changed via setValue with validate=true. Field1.ValidationStatus => Valid because fields are now equal.', () => {
        let setup = setupWithThreeValueHosts();
        setup.field1.setValue('ABC');
        setup.field2.setValue('BCD');

        expect(setup.field1.validationStatus).toBe(ValidationStatus.NeedsValidation);
        setup.field1.validate();
        expect(setup.field1.validationStatus).toBe(ValidationStatus.Invalid);

        setup.field2.setValue('ABC', { validate: true });  // will trigger OtherValueHostCHangedNotification with revalidate=false
        expect(setup.field1.validationStatus).toBe(ValidationStatus.Valid);
        expect(setup.field2.validationStatus).toBe(ValidationStatus.Invalid);   // we validated and its always invalid
        expect(setup.field3.validationStatus).toBe(ValidationStatus.NotAttempted);
    });
    test('Field1 previously validated. Change Field3 with revalidate=false. No change to Field1. Field3.ValidationState=>NotAttempted because it was not NeedsValidation', () => {
        let setup = setupWithThreeValueHosts();
        setup.field1.setValue('ABC');
        setup.field2.setValue('BCD');

        setup.field1.validate();    // field1 = Invalid

        expect(() => setup.field1.otherValueHostChangedNotification(
            setup.field3.getName(), false)).not.toThrow();
        expect(setup.field1.validationStatus).toBe(ValidationStatus.Invalid);
        expect(setup.field2.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.field3.validationStatus).toBe(ValidationStatus.NotAttempted);
    });
    test('Field1 previously validated. Use setValues to change Field3 with validate=false. No change to Field1. Field3.ValidationState=>ValueChangedButInvalided', () => {
        let setup = setupWithThreeValueHosts();
        setup.field1.setValue('ABC');   // Equal condition will fail
        setup.field2.setValue('BCD');
        setup.field3.setValue('');  // field3 is always Invalid

        setup.field1.validate();    // = invalid
        setup.field2.validate();    // = invalid
        setup.field3.validate();    // = invalid

        setup.field3.setValue('X');  // will trigger OtherValueHostCHangedNotification with revalidate=false
        expect(setup.field1.validationStatus).toBe(ValidationStatus.Invalid);  // no change
        expect(setup.field2.validationStatus).toBe(ValidationStatus.Invalid);   // when validated, always invalid
        expect(setup.field3.validationStatus).toBe(ValidationStatus.NeedsValidation);
    });

    test('Field1 previously validated. Use setValues to change Field3 with validate=true. No change to Field1.', () => {
        let setup = setupWithThreeValueHosts();
        setup.field1.setValue('ABC');   // Equal condition will fail
        setup.field2.setValue('BCD');
        setup.field3.setValue('');  // field3 is always Invalid
        setup.field1.validate();    // = invalid
        setup.field2.validate();    // = invalid
        setup.field3.validate();    // = invalid
        setup.field3.setValue('X', { validate: true });  // will trigger OtherValueHostCHangedNotification with revalidate=false
        expect(setup.field1.validationStatus).toBe(ValidationStatus.Invalid);  // no change
        expect(setup.field2.validationStatus).toBe(ValidationStatus.Invalid);   // when validated, always invalid
        expect(setup.field3.validationStatus).toBe(ValidationStatus.Invalid);  // when validated, always invalid
    });
    test('Field1 never validated but had been setValue. Use setValue to change Field2 with validate=true. Expect Field1 ValidationStatus=Valid because it was ValidationStatus=ValueChanged.', () => {
        let setup = setupWithThreeValueHosts();
        setup.field1.setValue('ABC');
        setup.field2.setValue('BCD');
        setup.field2.setValue('ABC', { validate: true }); 
        expect(setup.field1.validationStatus).toBe(ValidationStatus.Valid);
        expect(setup.field2.validationStatus).toBe(ValidationStatus.Invalid);   // when validated, always invalid
        expect(setup.field3.validationStatus).toBe(ValidationStatus.NotAttempted);

    });
});


describe('toIValidatorsValueHostBase function', () => {
    test('Passing actual ValidatorsValueHostBase matches interface returns same object.', () => {
        let vm = new MockValidationManager(new MockValidationServices(false, false));
        let testItem = new TestValidatorsValueHost(vm, {
            name: 'Field1',
            label: 'Label1',
            validatorConfigs: []
        },
            {
                name: 'Field1',
                value: undefined,
                issuesFound: null,
                status: ValidationStatus.NotAttempted,
            });
        expect(toIValidatorsValueHostBase(testItem)).toBe(testItem);
    });
    class TestIValidatorsValueHostBaseImplementation implements IValidatorsValueHostBase {
        valueHostsManager: IValidationManager = {} as IValidationManager;
        dispose(): void {}
        gatherValueHostNames(collection: Set<string>, valueHostResolver: IValueHostResolver): void {
            throw new Error("Method not implemented.");
        }


        getInputValue() {
            throw new Error("Method not implemented.");
        }
        setInputValue(value: any, options?: SetValueOptions | undefined): void {
            throw new Error("Method not implemented.");
        }
        setValues(nativeValue: any, inputValue: any, options?: SetValueOptions | undefined): void {
            throw new Error("Method not implemented.");
        }
        otherValueHostChangedNotification(valueHostIdThatChanged: string, revalidate: boolean): void {
            throw new Error("Method not implemented.");
        }
        validate(options?: ValidateOptions | undefined): ValueHostValidateResult {
            throw new Error("Method not implemented.");
        }
        clearValidation(): boolean {
            throw new Error("Method not implemented.");
        }
        isValid: boolean = true;
        validationStatus: ValidationStatus = ValidationStatus.NotAttempted;
        asyncProcessing: boolean = false;
        corrected: boolean = false;
        setBusinessLogicError(error: BusinessLogicError): boolean {
            throw new Error("Method not implemented.");
        }
        clearBusinessLogicErrors(): boolean {
            throw new Error("Method not implemented.");
        }
        doNotSave: boolean = false;
        getIssueFound(errorCode: string): IssueFound | null {
            throw new Error("Method not implemented.");
        }

        getIssuesFound(group?: string | undefined): IssueFound[] {
            throw new Error("Method not implemented.");
        }
        setIssuesFound(issuesFound: Array<IssueFound>, behavior: SetIssuesFoundErrorCodeMissingBehavior): boolean
        {
            throw new Error('Function not implemented.');
        }        
        getConversionErrorMessage(): string | null {
            throw new Error("Method not implemented.");
        }
        requiresInput: boolean = false;
        getName(): string {
            throw new Error("Method not implemented.");
        }
        getLabel(): string {
            throw new Error("Method not implemented.");
        }

        getValue() {
            throw new Error("Method not implemented.");
        }
        setValue(value: any, options?: SetValueOptions | undefined): void {
            throw new Error("Method not implemented.");
        }
        setValueToUndefined(options?: SetValueOptions | undefined): void {
            throw new Error("Method not implemented.");
        }
        getDataType(): string | null {
            throw new Error("Method not implemented.");
        }
        getDataTypeLabel(): string {
            throw new Error("Method not implemented.");
        }
        isChanged: boolean = false;
        isEnabled(): boolean {
            throw new Error("Method not implemented.");
        }
        setEnabled(enabled: boolean): void {
            throw new Error("Method not implemented.");
        }        
        saveIntoInstanceState(key: string, value: ValidTypesForInstanceStateStorage | undefined): void {
            throw new Error("Method not implemented.");
        }
        getFromInstanceState(key: string): ValidTypesForInstanceStateStorage | undefined {
            throw new Error("Method not implemented.");
        }
        getValidator(errorCode: string): IValidator | null {
            throw new Error("Method not implemented.");
        }

    }
    test('Passing object with interface match returns same object.', () => {
        let testItem = new TestIValidatorsValueHostBaseImplementation();

        expect(toIValidatorsValueHostBase(testItem)).toBe(testItem);
    });
    test('Non-matching interface returns null.', () => {
        let testItem = {};
        expect(toIValidatorsValueHostBase(testItem)).toBeNull();
    });
    test('null returns null.', () => {
        expect(toIValidatorsValueHostBase(null)).toBeNull();
    });
    test('Non-object returns null.', () => {
        expect(toIValidatorsValueHostBase(100)).toBeNull();
    });
});

describe('ValidatorsValueHostBaseGenerator members', () => {
    test('cleanupInstanceState existing state has no IssuesFound. Returns the same data', () => {
        let originalState: ValidatorsValueHostBaseInstanceState = {
            name: 'Field1',
            issuesFound: null,
            status: ValidationStatus.Valid,
            value: 10
        };
        let state = { ...originalState };
        let config: ValidatorsValueHostBaseConfig = {
            name: 'Field1',
            valueHostType: TestValueHostType,
            label: '',
            validatorConfigs: null
        };
        let testItem = new TestValidatorsValueHostGenerator();
        expect(() => testItem.cleanupInstanceState(state, config)).not.toThrow();
        expect(state).toEqual(originalState);
    });
    test('Using ConditionConfig, cleanupInstanceState existing state has no IssuesFound but there is a new ValidationConfig which has no impact. Returns the same data', () => {
        let originalState: ValidatorsValueHostBaseInstanceState = {
            name: 'Field1',
            issuesFound: null,
            status: ValidationStatus.Valid,
            value: 10
        };
        let state = { ...originalState };
        let config: ValidatorsValueHostBaseConfig = {
            name: 'Field1',
            valueHostType: TestValueHostType,
            label: '',
            validatorConfigs: [
                {
                    conditionConfig: <RequireTextConditionConfig>{
                        conditionType: ConditionType.RequireText,
                        valueHostName: null
                    },
                    errorMessage: ''
                }
            ]
        };
        let testItem = new TestValidatorsValueHostGenerator();
        expect(() => testItem.cleanupInstanceState(state, config)).not.toThrow();
        expect(state).toEqual(originalState);
    });
    test('Using ConditionCreator, cleanupInstanceState existing state has no IssuesFound but there is a new ValidationConfig which has no impact. Returns the same data', () => {
        let originalState: ValidatorsValueHostBaseInstanceState = {
            name: 'Field1',
            issuesFound: null,
            status: ValidationStatus.Valid,
            value: 10
        };
        let state = { ...originalState };
        let config: ValidatorsValueHostBaseConfig = {
            name: 'Field1',
            valueHostType: TestValueHostType,
            label: '',
            validatorConfigs: [
                {
                    conditionCreator: (requestor) => new RequireTextCondition({ conditionType: ConditionType.RequireText, valueHostName: 'Field1' }),
                    conditionConfig: null,
                    errorMessage: ''
                }
            ]
        };
        let testItem = new TestValidatorsValueHostGenerator();
        expect(() => testItem.cleanupInstanceState(state, config)).not.toThrow();
        expect(state).toEqual(originalState);
    });
    test('Using ConditionConfig, cleanupInstanceState existing state with ValidationStatus.Error has an IssuesFound and there is a ValidatorConfig. instanceState.IssuesFound unchanged', () => {
        let originalState: ValidatorsValueHostBaseInstanceState = {
            name: 'Field1',
            status: ValidationStatus.Invalid,
            value: 10,
            issuesFound: [],
        };
        originalState.issuesFound?.push({
            valueHostName: 'Field1',
            errorCode: ConditionType.RequireText,
            errorMessage: '',
            severity: ValidationSeverity.Error,
            summaryMessage: ''
        });
        let state = { ...originalState };
        let config: ValidatorsValueHostBaseConfig = {
            name: 'Field1',
            valueHostType: TestValueHostType,
            label: '',
            validatorConfigs: [
                {
                    conditionConfig: <RequireTextConditionConfig>{
                        conditionType: ConditionType.RequireText,
                        valueHostName: 'Field1'
                    },
                    errorMessage: ''
                }
            ]
        };
        let testItem = new TestValidatorsValueHostGenerator();
        expect(() => testItem.cleanupInstanceState(state, config)).not.toThrow();
        expect(state).toEqual(originalState);
    });
    test('Using ConditionCreator, cleanupInstanceState existing state with ValidationStatus.Error has an IssuesFound and there is a ValidatorConfig. instanceState.IssuesFound unchanged', () => {
        let originalState: ValidatorsValueHostBaseInstanceState = {
            name: 'Field1',
            status: ValidationStatus.Invalid,
            value: 10,
            issuesFound: [],
        };
        originalState.issuesFound?.push({
            valueHostName: 'Field1',
            errorCode: ConditionType.RequireText,
            errorMessage: '',
            severity: ValidationSeverity.Error,
            summaryMessage: ''
        });
        let state = { ...originalState };
        let config: ValidatorsValueHostBaseConfig = {
            name: 'Field1',
            valueHostType: TestValueHostType,
            label: '',
            validatorConfigs: [
                {
                    conditionCreator: (requestor) => new RequireTextCondition({ conditionType: ConditionType.RequireText, valueHostName: 'Field1' }),
                    conditionConfig: null,
                    errorMessage: ''
                }
            ]
        };
        let testItem = new TestValidatorsValueHostGenerator();
        expect(() => testItem.cleanupInstanceState(state, config)).not.toThrow();
        expect(state).toEqual(originalState);
    });
    test('Using ConditionConfig, cleanupInstanceState existing state has an IssuesFound but no associated ValidationConfig. instanceState.IssuesFound is null', () => {
        let originalState: ValidatorsValueHostBaseInstanceState = {
            name: 'Field1',
            status: ValidationStatus.Valid,
            value: 10,
            issuesFound: [],
        };
        originalState.issuesFound!.push({
            valueHostName: 'Field1',
            errorCode: ConditionType.RequireText,
            errorMessage: '',
            severity: ValidationSeverity.Warning,
            summaryMessage: ''
        });
        let state = { ...originalState };
        let config: ValidatorsValueHostBaseConfig = {
            name: 'Field1',
            valueHostType: TestValueHostType,
            label: '',
            validatorConfigs: [
                {
                    conditionConfig: <RangeConditionConfig>{
                        conditionType: ConditionType.Range,   // different type from in InstanceState
                        valueHostName: 'Field1'
                    },
                    errorMessage: ''
                }
            ]
        };
        let testItem = new TestValidatorsValueHostGenerator();
        expect(() => testItem.cleanupInstanceState(state, config)).not.toThrow();
        let expectedState = { ...originalState };
        expectedState.issuesFound = null;
        expect(state).toEqual(expectedState);
    });
    test('Using ConditionCreator, cleanupInstanceState existing state has an IssuesFound but no associated ValidationConfig. instanceState.IssuesFound is null', () => {
        let originalState: ValidatorsValueHostBaseInstanceState = {
            name: 'Field1',
            status: ValidationStatus.Valid,
            value: 10,
            issuesFound: [],
        };
        originalState.issuesFound!.push({
            valueHostName: 'Field1',
            errorCode: ConditionType.RequireText,
            errorMessage: '',
            severity: ValidationSeverity.Warning,
            summaryMessage: ''
        });
        let state = { ...originalState };
        let config: ValidatorsValueHostBaseConfig = {
            name: 'Field1',
            valueHostType: TestValueHostType,
            label: '',
            validatorConfigs: [
                {
                    conditionCreator: (requestor) => new NeverMatchesCondition({ conditionType: NeverMatchesConditionType }),
                    conditionConfig: null,
                    errorMessage: ''
                }
            ]
        };
        let testItem = new TestValidatorsValueHostGenerator();
        expect(() => testItem.cleanupInstanceState(state, config)).not.toThrow();
        let expectedState = { ...originalState };
        expectedState.issuesFound = null;
        expect(state).toEqual(expectedState);
    });

    test('cleanupInstanceState existing state with ValidationStatus=Invalid has an IssuesFound but no associated ValidationConfig. instanceState.IssuesFound is null and ValidationStatus is NeedsValidation', () => {
        let originalState: ValidatorsValueHostBaseInstanceState = {
            name: 'Field1',
            status: ValidationStatus.Invalid,
            value: 10,
            issuesFound: [],
        };
        originalState.issuesFound!.push({
            valueHostName: 'Field1',
            errorCode: ConditionType.RequireText,
            errorMessage: '',
            severity: ValidationSeverity.Error,
            summaryMessage: ''
        });
        let state = { ...originalState };
        let config: ValidatorsValueHostBaseConfig = {
            name: 'Field1',
            valueHostType: TestValueHostType,
            label: '',
            validatorConfigs: [
                {
                    conditionConfig: <RangeConditionConfig>{
                        conditionType: ConditionType.Range,   // different type from in InstanceState
                        valueHostName: 'Field1'
                    },
                    errorMessage: ''
                }
            ]
        };
        let testItem = new TestValidatorsValueHostGenerator();
        expect(() => testItem.cleanupInstanceState(state, config)).not.toThrow();
        let expectedState = { ...originalState };
        expectedState.issuesFound = null;
        expectedState.status = ValidationStatus.NeedsValidation;
        expect(state).toEqual(expectedState);
    });
    test('cleanupInstanceState existing state with ValidationStatus=Invalid, 2 IssuesFound where one is Warning and the other is removed. State.IssuesFound is the warning and ValidationStatus is Valid', () => {
        let originalState: ValidatorsValueHostBaseInstanceState = {
            name: 'Field1',
            status: ValidationStatus.Invalid,
            value: 10,
            issuesFound: [],
        };
        originalState.issuesFound!.push({
            valueHostName: 'Field1',
            errorCode: ConditionType.RequireText,
            errorMessage: '',
            severity: ValidationSeverity.Error,
            summaryMessage: ''
        });
        originalState.issuesFound!.push({
            valueHostName: 'Field1',
            errorCode: NeverMatchesConditionType,
            errorMessage: '',
            severity: ValidationSeverity.Warning,
            summaryMessage: ''
        });
        let state = { ...originalState };
        let config: ValidatorsValueHostBaseConfig = {
            name: 'Field1',
            valueHostType: TestValueHostType,
            label: '',
            validatorConfigs: [
                {
                    conditionConfig: {
                        conditionType: NeverMatchesConditionType
                    },
                    errorMessage: ''
                }
                // we've abandoned ConditionType.RequireText which was severity=Error
            ]
        };
        let testItem = new TestValidatorsValueHostGenerator();
        expect(() => testItem.cleanupInstanceState(state, config)).not.toThrow();
        let expectedState = { ...originalState };
        expectedState.issuesFound!.splice(0, 1);
        expectedState.status = ValidationStatus.Valid;
        expect(state).toEqual(expectedState);
    });
    test('cleanupInstanceState existing state with ValidationStatus=Invalid, 3 IssuesFound (Error, Warning, Error) and one Error is removed. State.IssuesFound is the warning and the remaining error and ValidationStatus is Invalid', () => {
        let originalState: ValidatorsValueHostBaseInstanceState = {
            name: 'Field1',
            status: ValidationStatus.Invalid,
            value: 10,
            issuesFound: [],
        };
        originalState.issuesFound!.push({
            valueHostName: 'Field1',
            errorCode: ConditionType.RequireText,
            errorMessage: '',
            severity: ValidationSeverity.Error,
            summaryMessage: ''
        });
        originalState.issuesFound!.push({
            valueHostName: 'Field1',
            errorCode: NeverMatchesConditionType,
            errorMessage: '',
            severity: ValidationSeverity.Warning,
            summaryMessage: ''
        });
        originalState.issuesFound!.push({
            valueHostName: 'Field1',
            errorCode: ConditionType.Range,
            errorMessage: '',
            severity: ValidationSeverity.Error,
            summaryMessage: ''
        });
        let state = { ...originalState };
        let config: ValidatorsValueHostBaseConfig = {
            name: 'Field1',
            valueHostType: TestValueHostType,
            label: '',
            validatorConfigs: [
                {
                    conditionConfig: {
                        conditionType: NeverMatchesConditionType
                    },
                    errorMessage: ''
                },
                {
                    conditionConfig: <RangeConditionConfig>{
                        conditionType: ConditionType.Range,
                        valueHostName: null
                    },
                    errorMessage: ''
                }
                // we've abandoned ConditionType.RequireText which was severity=Error
            ]
        };
        let testItem = new TestValidatorsValueHostGenerator();
        expect(() => testItem.cleanupInstanceState(state, config)).not.toThrow();
        let expectedState = { ...originalState };
        expectedState.issuesFound!.splice(0, 1);
        expectedState.status = ValidationStatus.Invalid;
        expect(state).toEqual(expectedState);
    });
    test('cleanupInstanceState existing state with ValidationStatus=Invalid, 3 IssuesFound (Error, Warning, Severe) where Error is removed. State.IssuesFound is Warning, Severe and ValidationStatus is Invalid', () => {
        let originalState: ValidatorsValueHostBaseInstanceState = {
            name: 'Field1',
            status: ValidationStatus.Invalid,
            value: 10,
            issuesFound: [],
        };
        originalState.issuesFound!.push({
            valueHostName: 'Field1',
            errorCode: ConditionType.RequireText,
            errorMessage: '',
            severity: ValidationSeverity.Error,
            summaryMessage: ''
        });
        originalState.issuesFound!.push({
            valueHostName: 'Field1',
            errorCode: NeverMatchesConditionType,
            errorMessage: '',
            severity: ValidationSeverity.Warning,
            summaryMessage: ''
        });
        originalState.issuesFound!.push({
            valueHostName: 'Field1',
            errorCode: ConditionType.Range,
            errorMessage: '',
            severity: ValidationSeverity.Severe,
            summaryMessage: ''
        });
        let state = { ...originalState };
        let config: ValidatorsValueHostBaseConfig = {
            name: 'Field1',
            valueHostType: TestValueHostType,
            label: '',
            validatorConfigs: [
                {
                    conditionConfig: {
                        conditionType: NeverMatchesConditionType
                    },
                    errorMessage: ''
                },
                {
                    conditionConfig: <RangeConditionConfig>{
                        conditionType: ConditionType.Range,
                        valueHostName: null
                    },
                    errorMessage: ''
                }
                // we've abandoned ConditionType.RequireText which was severity=Error
            ]
        };
        let testItem = new TestValidatorsValueHostGenerator();
        expect(() => testItem.cleanupInstanceState(state, config)).not.toThrow();
        let expectedState = { ...originalState };
        expectedState.issuesFound!.splice(0, 1);
        expectedState.status = ValidationStatus.Invalid;
        expect(state).toEqual(expectedState);
    });
    test('createInstanceState returns instance with name and InitialValue from Config', () => {
        let testItem = new TestValidatorsValueHostGenerator();
        let config: ValidatorsValueHostBaseConfig = {
            name: 'Field1',
            valueHostType: TestValueHostType,
            label: '',
            initialValue: 'TEST',
            validatorConfigs: [
                {
                    conditionConfig: <RequireTextConditionConfig>{
                        conditionType: ConditionType.RequireText,
                        valueHostName: 'Field1'
                    },
                    errorMessage: '',
                }
            ]
        };
        let state: ValidatorsValueHostBaseInstanceState | null = null;
        expect(() => state = testItem.createInstanceState(config)).not.toThrow();
        expect(state).not.toBeNull();
        expect(state!.name).toBe(config.name);
        expect(state!.status).toBe(ValidationStatus.NotAttempted);
        expect(state!.group).toBeUndefined();
        expect(state!.value).toBe(config.initialValue);
        expect(state!.issuesFound).toBeNull();
    });
});
describe('dispose', () => {

    test('dispose kills many references including state and config', () => {
        let setup = setupValidatorsValueHostBase({
            validatorConfigs: [
                {
                    conditionConfig: {
                        conditionType: ConditionType.RequireText
                    }
                }
            ]
        });
        let vhConfig = setup.config;
        setup.valueHost.validate(); // ensure validators and conditions are created, so we can test disposing them
        setup.valueHost.dispose();
        expect(setup.valueHost.exposeValidators).toBeUndefined();
        expect(setup.valueHost.exposeState).toBeUndefined();
        expect(setup.valueHost.exposeConfig).toBeUndefined();            
        expect(() => setup.valueHost.getValue()).toThrow(TypeError);  // value is from config which is undefined
        expect(() => setup.valueHost.exposeServices).toThrow(TypeError);

    });   
    
    test('dispose with ValidatorsValueHostBaseConfig having its own dispose kills what the config.dispose expects', () => {
        interface X extends ValidatorsValueHostBaseConfig, IDisposable
        {
            x: {}
        }

        let setup = setupValidatorsValueHostBase();
        let vhConfig: X = {
            ...setup.config,
            x: {},
            dispose: () => { (vhConfig.x as any) = undefined }
        };
        let newVH = setup.validationManager.addOrUpdateValueHost(vhConfig, null);
        setup.valueHost = newVH as TestValidatorsValueHost;

        setup.valueHost.validate();         

        setup.valueHost.dispose();

        expect(vhConfig.x).toBeUndefined();

    });               

});