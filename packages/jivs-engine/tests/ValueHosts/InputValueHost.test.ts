import { RegExpConditionConfig, RegExpCondition } from "../../src/Conditions/ConcreteConditions";
import { InputValueHost, InputValueHostGenerator, toIInputValueHost } from "../../src/ValueHosts/InputValueHost";
import { LoggingCategory, LoggingLevel } from "../../src/Interfaces/LoggerService";
import { ValidationManager } from "../../src/Validation/ValidationManager";
import { MockValidationServices, MockValidationManager } from "../TestSupport/mocks";
import { InputValueHostConfig, InputValueHostInstanceState, IInputValueHost, IInputValueHostCallbacks, toIInputValueHostCallbacks, SetInputValueOptions } from "../../src/Interfaces/InputValueHost";
import {
    ValidationStatus, IssueFound, ValueHostValidateResult, ValidationSeverity, ValidateOptions,
    BusinessLogicError,
    SetIssuesFoundErrorCodeMissingBehavior
} from "../../src/Interfaces/Validation";
import { IValidator, ValidatorConfig } from "../../src/Interfaces/Validator";
import { IValidationManager, ValidationManagerConfig } from "../../src/Interfaces/ValidationManager";
import { SetValueOptions, IValueHost, ValueHostInstanceState, ValidTypesForInstanceStateStorage, ValueHostConfig } from "../../src/Interfaces/ValueHost";
import { ConditionCategory, ICondition, ConditionConfig, IConditionFactory } from "../../src/Interfaces/Conditions";
import { ConditionFactory } from "../../src/Conditions/ConditionFactory";
import { IValueHostResolver } from "../../src/Interfaces/ValueHostResolver";
import { TextLocalizerService } from "../../src/Services/TextLocalizerService";
import { ConditionType } from "../../src/Conditions/ConditionTypes";
import { LookupKey } from "../../src/DataTypes/LookupKeys";
import { ValueHostType } from "../../src/Interfaces/ValueHostFactory";
import { IDataTypeCheckGenerator } from "../../src/Interfaces/DataTypeCheckGenerator";
import { AutoGenerateDataTypeCheckService } from "../../src/Services/AutoGenerateDataTypeCheckService";
import { StaticValueHost } from '../../src/ValueHosts/StaticValueHost';
import { IValidatableValueHostBase, ValueHostValidationState } from "../../src/Interfaces/ValidatableValueHostBase";
import { AlwaysMatchesConditionType, NeverMatchesConditionType, UserSuppliedResultConditionType } from "../TestSupport/conditionsForTesting";
import { FluentValidatorBuilder } from "../../src/ValueHosts/Fluent";
import { CapturingLogger } from "../TestSupport/CapturingLogger";
import { PropertyValueHost } from "../../src/ValueHosts/PropertyValueHost";
import { CalcValueHost } from "../../src/ValueHosts/CalcValueHost";
import { registerDataTypeParsers } from "../TestSupport/createValidationServices";
import { IDataTypeParser } from "../../src/Interfaces/DataTypeParsers";
import { CodingError } from "../../src/Utilities/ErrorHandling";
import { DataTypeResolution } from "../../src/Interfaces/DataTypes";

interface ITestSetupConfig {
    services: MockValidationServices,
    validationManager: MockValidationManager,
    config: InputValueHostConfig,
    state: InputValueHostInstanceState,
    valueHost: InputValueHost
};

function createInputValueHostConfig(fieldNumber: number = 1,
    dataType: string = LookupKey.String,
    initialValue?: any): InputValueHostConfig {
    return {
        name: 'Field' + fieldNumber,
        label: 'Label' + fieldNumber,
        valueHostType: ValueHostType.Input,
        dataType: dataType,
        initialValue: initialValue,
        validatorConfigs: []
    };
}

function finishPartialInputValueHostConfig(partialConfig: Partial<InputValueHostConfig> | null):
    InputValueHostConfig {
    let defaultIVH = createInputValueHostConfig(1, LookupKey.String);
    if (partialConfig) {
        return { ...defaultIVH, ...partialConfig };
    }
    return defaultIVH;
}

function finishPartialInputValueHostConfigs(partialConfigs: Array<Partial<InputValueHostConfig>> | null):
    Array<InputValueHostConfig> | null {
    let result: Array<InputValueHostConfig> = [];
    if (partialConfigs) {
        for (let i = 0; i < partialConfigs.length; i++) {
            let vhd = partialConfigs[i];
            result.push(finishPartialInputValueHostConfig(vhd));
        }
    }

    return result;
}


function createValidatorConfig(condConfig: ConditionConfig | null): ValidatorConfig {
    return {
        conditionConfig: condConfig,
        errorMessage: 'Local',
        summaryMessage: 'Summary',
    };
}
function finishPartialValidatorConfig(validatorConfig: Partial<ValidatorConfig> | null):
    ValidatorConfig {
    let defaultIVD = createValidatorConfig(null);
    if (validatorConfig) {
        return { ...defaultIVD, ...validatorConfig };
    }
    return defaultIVD;
}

function finishPartialValidatorConfigs(validatorConfigs: Array<Partial<ValidatorConfig>> | null):
    Array<ValidatorConfig> {
    let result: Array<ValidatorConfig> = [];
    if (validatorConfigs) {
        let defaultIVD = createValidatorConfig(null);
        for (let i = 0; i < validatorConfigs.length; i++) {
            let vd = validatorConfigs[i];
            result.push(finishPartialValidatorConfig(vd));
        }
    }

    return result;
}

function createInputValueHostInstanceState(fieldNumber: number = 1): InputValueHostInstanceState {
    return {
        name: 'Field' + fieldNumber,
        value: undefined,
        inputValue: undefined,
        issuesFound: null,
        status: ValidationStatus.NotAttempted
    };
}
function finishPartialInputValueHostInstanceState(partialState: Partial<InputValueHostInstanceState> | null): InputValueHostInstanceState {
    let defaultIVS = createInputValueHostInstanceState(1);
    if (partialState) {
        return { ...defaultIVS, ...partialState };
    }
    return defaultIVS;
}

/**
 * Returns an ValueHost (PublicifiedValueHost subclass) ready for testing.
 * @param partialIVHConfig - Provide just the properties that you want to test.
 * Any not supplied but are required will be assigned using these rules:
 * name: 'Field1',
 * label: 'Label1',
 * valueHostType: 'Input',
 * DataType: LookupKey.String,
 * InitialValue: 'DATA'
 * validatorConfigs: []
 * @param partialState - Use the default state by passing null. Otherwise pass
 * a state. Your state will override default values. To avoid overriding,
 * pass the property with a value of undefined.
 * These are the default values
 * name: 'Field1'
 * Value: undefined
 * InputValue: undefined
 * IssuesFound: null,
 * ValidationStatus: NotAttempted
 * @returns An object with all of the parts that were setup including 
 * ValidationManager, Services, ValueHosts, the complete Config,
 * and the state.
 */
function setupInputValueHost(
    partialIVHConfig?: Partial<InputValueHostConfig> | null,
    partialState?: Partial<InputValueHostInstanceState> | null): ITestSetupConfig {
    let services = new MockValidationServices(true, true);
    let vm = new MockValidationManager(services);
    let updatedConfig = finishPartialInputValueHostConfig(partialIVHConfig ?? null);
    let updatedState = finishPartialInputValueHostInstanceState(partialState ?? null);

    let vh = vm.addInputValueHostWithConfig(updatedConfig, updatedState);
    //new InputValueHost(vm, updatedConfig, updatedState);
    return {
        services: services,
        validationManager: vm,
        config: updatedConfig,
        state: updatedState,
        valueHost: vh as InputValueHost
    };
}

/**
 * Creates a configuration where you can call validate() and test various results.
 * @param partialValidatorConfigs - Always provide a list of the validatorConfigs in the desired order.
 * If null, no validators are made available to validate
 * @param partialInputValueState - Use to supply initial InputValue and Value properties. Any property
 * not supplied will be provided.
 * @returns Configuration that has been setup. Use valueHost to invoke validation functions.
 */
function setupInputValueHostForValidate(
    partialValidatorConfigs: Array<Partial<ValidatorConfig>> | null,
    partialInputValueState: Partial<InputValueHostInstanceState> | null,
    vhGroup?: string | null): ITestSetupConfig {

    let inputValueConfig: Partial<InputValueHostConfig> = {
        validatorConfigs: partialValidatorConfigs ?
            finishPartialValidatorConfigs(partialValidatorConfigs) :
            undefined
    };
    if (vhGroup !== undefined)
        inputValueConfig.group = vhGroup;

    let updatedState = finishPartialInputValueHostInstanceState(
        { ...{ inputValue: '' }, ...partialInputValueState });

    return setupInputValueHost(inputValueConfig, updatedState);
}

describe('constructor and resulting property values', () => {

    test('constructor with valid parameters created and sets up Services, Config, and InstanceState', () => {
        let services = new MockValidationServices(true, true);
        let vm = new MockValidationManager(services);
        let testItem: InputValueHost | null = null;
        expect(()=> testItem = new InputValueHost(vm, {
            name: 'Field1',
            valueHostType: ValueHostType.Input,
            validatorConfigs: []
            },
            {
                name: 'Field1',
                status: ValidationStatus.NotAttempted,
                issuesFound: null,
                value: undefined
            })).not.toThrow();

        expect(testItem!.valueHostsManager).toBe(vm);

        expect(testItem!.getName()).toBe('Field1');
        expect(testItem!.getLabel()).toBe('');
        expect(testItem!.getDataType()).toBeNull();
        expect(testItem!.getValue()).toBeUndefined();
        expect(testItem!.isChanged).toBe(false);
        expect(testItem!.isValid).toBe(true);
        expect(testItem!.asyncProcessing).toBe(false);
        expect(testItem!.corrected).toBe(false);        
        expect(testItem!.requiresInput).toBe(false);
        expect(testItem!.getConversionErrorMessage()).toBeNull();
        expect(testItem!.getParserLookupKey()).toBeUndefined();
    });
});

describe('setValue', () => {

    test('ConversionErrorTokenValue supplied and is ignored by setValue.', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValue(undefined, { conversionErrorTokenValue: 'ERROR' })).not.toThrow();
        expect(setup.valueHost.getConversionErrorMessage()).toBe('ERROR');
    });
    test('ConversionErrorTokenValue supplied but is not saved because value is defined', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValue(10, { conversionErrorTokenValue: 'ERROR' })).not.toThrow();
        expect(setup.valueHost.getConversionErrorMessage()).toBeNull();
    });
    test('ConversionErrorTokenValue supplied in one call which saves it but a follow up call without it abandons it', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValue(undefined, { conversionErrorTokenValue: 'ERROR' })).not.toThrow();
        setup.valueHost.setValue(10, { conversionErrorTokenValue: 'ERROR' });
        expect(setup.valueHost.getConversionErrorMessage()).toBeNull();
    });
    test('Use both ConversionErrorTokenValue and Reset options will setup the error message and IsChanged is false', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValue(undefined, { conversionErrorTokenValue: 'ERROR', reset: true })).not.toThrow();
        expect(setup.valueHost.getConversionErrorMessage()).toBeNull();
        expect(setup.valueHost.isChanged).toBe(false);
    });
    test('Value was changed. OnValueChanged called. (confirm ancestor was not broken)', () => {
        let setup = setupInputValueHost();
        let testItem = setup.valueHost;

        let callbackInvoked = 0;
        setup.validationManager.onValueChanged = (valueHost, oldValue) => {
            callbackInvoked++;
        };
        testItem.setValue(100);
        expect(callbackInvoked).toBe(1);

    });

    test('Value was changed. OnValueHostInstanceStateChanged called.(confirm ancestor was not broken) ', () => {
        const initialValue = 100;

        let setup = setupInputValueHost();
        let callbackInvoked = 0;
        setup.validationManager.onValueHostInstanceStateChanged = (valueHost, stateToRetain) => {
            callbackInvoked++;
        };        
        let testItem = setup.valueHost;
        testItem.setValue(initialValue);

        expect(callbackInvoked).toBe(1);
    });

});
describe('InputValueHost.getInputValue', () => {
    test('Set instanceState.InputValue to undefined; getInputValue is undefined', () => {
        let setup = setupInputValueHost(null, {
            inputValue: undefined
        });
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NotAttempted);
        let value: any = null;
        expect(() => value = setup.valueHost.getInputValue()).not.toThrow();
        expect(value).toBeUndefined();
    });
    test('Set instanceState.InputValue to null; getInputValue is null', () => {
        let setup = setupInputValueHost(null, {
            inputValue: null
        });
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NotAttempted);
        let value: any = null;
        expect(() => value = setup.valueHost.getInputValue()).not.toThrow();
        expect(value).toBeNull();
    });
    test('Set instanceState.InputValue to "abc"; getInputValue is "abc"', () => {
        let setup = setupInputValueHost(null, {
            inputValue: 'abc'
        });
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NotAttempted);
        let value: any = null;
        expect(() => value = setup.valueHost.getInputValue()).not.toThrow();
        expect(value).toBe('abc');
    });

});

describe('setInputValue with getInputValue to check result', () => {
    function testWithoutValidation(inputValue: any,
        options: SetInputValueOptions| null | undefined): void
    {
        let setup = setupInputValueHost();
        setup.services.dataTypeParserService.enabled = false;

        expect(() => setup.valueHost.setInputValue(inputValue, options!)).not.toThrow();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.valueHost.isChanged).toBe(true);
        expect(setup.valueHost.getInputValue()).toBe(inputValue);
        let changes = setup.validationManager.getHostStateChanges();
        expect(changes.length).toBe(1);
        expect((<InputValueHostInstanceState>changes[0]).inputValue).toBe(inputValue);
        expect((<InputValueHostInstanceState>changes[0]).changeCounter).toBe(1);        
    }
    test('Value of "ABC", options is undefined. Sets value to "ABC" and does not validate. IsChanged is true', () => {
        testWithoutValidation("ABC", undefined);
    });
    test('Value of "ABC", options is empty object. Sets value to "ABC" and does not validate', () => {
        testWithoutValidation("ABC", {});
    });
    test('Value of "ABC", options is null. Sets value to "ABC" and does not validate', () => {
        testWithoutValidation("ABC", null);
    });
    test('Value of "ABC", options is { validate: false }. Sets value to "ABC" and does not validate', () => {
        testWithoutValidation("ABC", { validate: false });
    });
    test('Value of "ABC", options is { validate: true }. Sets value to "ABC" and validate (no Validators to cause Invalid, so result is Undetermined)', () => {
        let setup = setupInputValueHost();
        setup.services.dataTypeParserService.enabled = false;

        expect(() => setup.valueHost.setInputValue("ABC", { validate: true })).not.toThrow();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Undetermined);
        expect(setup.valueHost.isChanged).toBe(true);
        expect(setup.valueHost.getInputValue()).toBe("ABC");
        let changes = setup.validationManager.getHostStateChanges();
        expect(changes.length).toBe(2); // first changes the value; second changes ValidationStatus
        let valueChange = <InputValueHostInstanceState>changes[0];
        expect(valueChange.inputValue).toBe("ABC");
        let vrChange = <InputValueHostInstanceState>changes[1];
        expect(vrChange.status).toBe(ValidationStatus.Undetermined);
        expect(vrChange.changeCounter).toBe(1);
    });
    test('Before calling, validate for ValidationStatus=Undetermined. Set value to 10 with options { Reset: true }. Expect value to be 20, IsChanged = false, and ValidationStatus to NotAttempted', () => {
        let setup = setupInputValueHost();
        setup.services.dataTypeParserService.enabled = false;

        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NotAttempted);
        setup.valueHost.validate();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Undetermined);
        expect(() => setup.valueHost.setInputValue('ABC', { reset: true })).not.toThrow();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NotAttempted);
        expect(setup.valueHost.getIssuesFound()).toBeNull();
        expect(setup.valueHost.isChanged).toBe(false);
    });
    test('ConversionErrorTokenValue supplied and is applied because native value is undefined', () => {
        let setup = setupInputValueHost();
        setup.services.dataTypeParserService.enabled = false;

        expect(() => setup.valueHost.setInputValue("ABC", { conversionErrorTokenValue: 'ERROR' })).not.toThrow();
        expect(setup.valueHost.getConversionErrorMessage()).toBe('ERROR');
    });
    test('ConversionErrorTokenValue supplied and is ignored because native value is defined', () => {
        let setup = setupInputValueHost();
        setup.services.dataTypeParserService.enabled = false;
        setup.valueHost.setValue('ABC');
        expect(() => setup.valueHost.setInputValue("ABC", { conversionErrorTokenValue: 'ERROR' })).not.toThrow();
        expect(setup.valueHost.getConversionErrorMessage()).toBeNull();
    });    
    test('ConversionErrorTokenValue supplied in previous setValueToUndefined, and retained by SetInputValue despite not setting native value here', () => {
        let setup = setupInputValueHost();
        setup.services.dataTypeParserService.enabled = false;

        setup.valueHost.setValueToUndefined({ conversionErrorTokenValue: 'ERROR' });

        expect(() => setup.valueHost.setInputValue("ABC", { conversionErrorTokenValue: 'ERROR' })).not.toThrow();
        expect(setup.valueHost.getConversionErrorMessage()).toBe('ERROR');
    });
    test('Log call when Level=Debug.', () => {
        const initialValue = 'A';
        const finalValue = 'B';
        let setup = setupInputValueHost({}, { value: initialValue } );
        setup.services.loggerService.minLevel = LoggingLevel.Debug;
        let testItem = setup.valueHost;
        testItem.setInputValue(finalValue);
        let logger = setup.services.loggerService as CapturingLogger;
        expect(logger.findMessage('setInputValue\\("B"\\)', LoggingLevel.Debug, null)).toBeTruthy();
    });
    test('isEnabled=false will not change the value.', () => {
        const initialValue = 'A';   // this is the native value
        const finalValue = 'B';
        let setup = setupInputValueHost({}, { value: initialValue } );
        setup.services.loggerService.minLevel = LoggingLevel.Debug;
        let testItem = setup.valueHost;
        testItem.setEnabled(false);
        testItem.setInputValue(finalValue);
        expect(testItem.getInputValue()).toBeUndefined();   // never set it
        let logger = setup.services.loggerService as CapturingLogger;
        expect(logger.findMessage('ValueHost "Field1" disabled.', LoggingLevel.Warn, null)).toBeTruthy();
        expect(logger.findMessage('overrideDisabled', LoggingLevel.Info, null)).toBeNull();
    });
    test('isEnabled=false will change the value when option.overrideDisabled=true.', () => {
        const initialValue = 'A';
        const finalValue = 'B';
        let setup = setupInputValueHost({}, { value: initialValue } );
        setup.services.loggerService.minLevel = LoggingLevel.Debug;
        let testItem = setup.valueHost;
        testItem.setEnabled(false);
        testItem.setInputValue(finalValue, { overrideDisabled: true });
        expect(testItem.getInputValue()).toBe(finalValue);
        let logger = setup.services.loggerService as CapturingLogger;
        expect(logger.findMessage('overrideDisabled', LoggingLevel.Info, null)).toBeTruthy();
        expect(logger.findMessage('ValueHost "Field1" disabled.', LoggingLevel.Warn, null)).toBeNull();
    });    
});
describe('setInputValue with parser enabled to see both input value and native values are assigned', () => {
    function testWithParser(inputValue: any,
        nativeDataTypeLookupKey: string,
        parserLookupKey: string | null | undefined,
        parserCreator: undefined | ((valueHost: IInputValueHost) => IDataTypeParser<any>),
        options: SetInputValueOptions| null | undefined,
        expectedNativeValue: any,
        expectParserCreatorToBeCalled: boolean = false
        ): ITestSetupConfig
    {
        let ivh: InputValueHostConfig = {
            name: 'Field1',
            validatorConfigs: [],
            dataType: nativeDataTypeLookupKey,
            parserLookupKey: parserLookupKey,
            parserCreator: parserCreator
        }
        let setup = setupInputValueHost(ivh);
        setup.services.loggerService.minLevel = LoggingLevel.Debug;
        registerDataTypeParsers(setup.services.dataTypeParserService);
        setup.services.lookupKeyFallbackService.register(LookupKey.Integer, LookupKey.Number);

        expect(() => setup.valueHost.setInputValue(inputValue, options!)).not.toThrow();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.valueHost.isChanged).toBe(true);
        expect(setup.valueHost.getInputValue()).toBe(inputValue);
        expect(setup.valueHost.getValue()).toBe(expectedNativeValue);     
        expect(setup.valueHost.getConversionErrorMessage()).toBeNull();
        expect(setup.valueHost.getParserLookupKey()).toBe(parserLookupKey);
        let logger = setup.services.loggerService as CapturingLogger;
        expect(logger.findMessage('Attempt to parse into native value', LoggingLevel.Debug,    
            null)).toBeTruthy();  
        expect(logger.findMessage('Parsed into native value', LoggingLevel.Debug,    
            null)).toBeTruthy();
        if (expectParserCreatorToBeCalled)
            expect(logger.findMessage('Parsing', LoggingLevel.Info,    
                null)).toBeTruthy();
        return setup;
    }
    function testWithParserWithErrorMessage(inputValue: any,
        nativeDataTypeLookupKey: string,
        parserLookupKey: string | null | undefined,
        parserCreator: undefined | ((valueHost: IInputValueHost) => IDataTypeParser<any>),
        options: SetInputValueOptions| null | undefined
        ): ITestSetupConfig
    {
        let ivh: InputValueHostConfig = {
            name: 'Field1',
            validatorConfigs: [],
            dataType: nativeDataTypeLookupKey,
            parserLookupKey: parserLookupKey,
            parserCreator: parserCreator
        }
        let setup = setupInputValueHost(ivh);
        setup.services.loggerService.minLevel = LoggingLevel.Debug;
        registerDataTypeParsers(setup.services.dataTypeParserService);
        setup.services.lookupKeyFallbackService.register(LookupKey.Integer, LookupKey.Number);

        expect(() => setup.valueHost.setInputValue(inputValue, options!)).not.toThrow();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.valueHost.isChanged).toBe(true);
        expect(setup.valueHost.getInputValue()).toBe(inputValue);
        expect(setup.valueHost.getValue()).toBeUndefined();     
        expect(setup.valueHost.getConversionErrorMessage()).toBeTruthy();
        let logger = setup.services.loggerService as CapturingLogger;
        expect(logger.findMessage('Attempt to parse into native value', LoggingLevel.Debug,    
            null)).toBeTruthy();  
        expect(logger.findMessage('Parser reported error', LoggingLevel.Debug,    
            null)).toBeTruthy();  

        return setup;
    }    
    function testWithParserWhereErrorIsThrown(inputValue: any,
        nativeDataTypeLookupKey: string,
        parserLookupKey: string | null | undefined,
        parserCreator: undefined | ((valueHost: IInputValueHost) => IDataTypeParser<any>),
        options: SetInputValueOptions| null | undefined,
        errorMsg: string
        ): ITestSetupConfig
    {
        let ivh: InputValueHostConfig = {
            name: 'Field1',
            validatorConfigs: [],
            dataType: nativeDataTypeLookupKey,
            parserLookupKey: parserLookupKey,
            parserCreator: parserCreator
        }
        let setup = setupInputValueHost(ivh);
        setup.services.loggerService.minLevel = LoggingLevel.Debug;
        registerDataTypeParsers(setup.services.dataTypeParserService);
        setup.services.lookupKeyFallbackService.register(LookupKey.Integer, LookupKey.Number);

        let regex = new RegExp(errorMsg);
        expect(() => setup.valueHost.setInputValue(inputValue, options!)).toThrow(regex);
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NotAttempted);
        expect(setup.valueHost.isChanged).toBe(false);
        expect(setup.valueHost.getInputValue()).toBeUndefined();
        expect(setup.valueHost.getValue()).toBeUndefined();     
        expect(setup.valueHost.getConversionErrorMessage()).toBeNull();
        let logger = setup.services.loggerService as CapturingLogger;
        expect(logger.findMessage('Attempt to parse into native value', LoggingLevel.Debug,    
            null)).toBeTruthy();
        expect(logger.findMessage(errorMsg, LoggingLevel.Error,    
            LoggingCategory.Exception)).toBeTruthy();
        return setup;
    }        
    function testWithDisabledParser(inputValue: any,
        nativeDataTypeLookupKey: string,
        parserLookupKey: string | null | undefined, // when null, no parser
        parserCreator: undefined | ((valueHost: IInputValueHost) => IDataTypeParser<any>),
        options: SetInputValueOptions | null | undefined,    // when disableParser = true
        isActiveParser: boolean = true  // when false, no parser
        ): ITestSetupConfig
    {
        let ivh: InputValueHostConfig = {
            name: 'Field1',
            validatorConfigs: [],
            dataType: nativeDataTypeLookupKey,
            parserLookupKey: parserLookupKey,
            parserCreator: parserCreator
        }
        let setup = setupInputValueHost(ivh);
        setup.services.loggerService.minLevel = LoggingLevel.Debug;
        setup.services.dataTypeParserService.enabled = isActiveParser;
        registerDataTypeParsers(setup.services.dataTypeParserService);
        setup.services.lookupKeyFallbackService.register(LookupKey.Integer, LookupKey.Number);

        expect(() => setup.valueHost.setInputValue(inputValue, options!)).not.toThrow();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.valueHost.isChanged).toBe(true);
        expect(setup.valueHost.getInputValue()).toBe(inputValue);    
        expect(setup.valueHost.getConversionErrorMessage()).toBeNull();
        let logger = setup.services.loggerService as CapturingLogger;
        if (options && options.disableParser)
            expect(logger.findMessage('option.disableParser=true', LoggingLevel.Debug,
                null)).toBeTruthy();
        return setup;
    }    
// trims then appends '!' to show this function was applied
    function parserFnTrimString(valueHost: IInputValueHost): IDataTypeParser<string>
    {
        return <IDataTypeParser<string>>{
            supports(dataTypeLookupKey : string, cultureId: string, text: string): boolean {
                return !dataTypeLookupKey || (dataTypeLookupKey === LookupKey.String);
            },
            parse(text: string, dataTypeLookupKey: string, cultureId: string): DataTypeResolution<string> {
                return { value: text.trim() + '!' };
            },
        }
    }
    // converts to a number then adds 1 to show this function was applied.
    function parserFnToNumber(valueHost: IInputValueHost): IDataTypeParser<number>
    {
        return <IDataTypeParser<number>>{
            supports(dataTypeLookupKey : string, cultureId: string, text: string): boolean {
                return !dataTypeLookupKey || dataTypeLookupKey === LookupKey.Number;
            },
            parse(text: string, dataTypeLookupKey: string, cultureId: string): DataTypeResolution<number> {
                let num = parseFloat(text);
                if (!isNaN(num))
                    return { value: num + 1 };
                
                return { errorMessage: 'Invalid data type ' };
            },
        }
    }    
    function parserFnThrows(valueHost: IInputValueHost): IDataTypeParser<string>
    {
        return <IDataTypeParser<string>>{
            supports(dataTypeLookupKey : string, cultureId: string, text: string): boolean {
                return true;
            },
            parse(text: string, dataTypeLookupKey: string, cultureId: string): DataTypeResolution<string> {
                throw new CodingError('ERROR');
            },
        }
    }    

    test('As a string with dataType=string, expecting to parse and update native value. The parser will be CleanupStringParser set only to trim. This parser does not encounter any errors', () => {
        testWithParser('ABC', LookupKey.String, undefined, undefined, {}, 'ABC');
        testWithParser(' ABC ', LookupKey.String, undefined, undefined, {}, 'ABC');     
        testWithParser('ABC', LookupKey.String, LookupKey.String, undefined, {}, 'ABC');     
        testWithParser('ABC', null!, LookupKey.String, undefined, {}, 'ABC');         
        testWithParser('ABC', undefined!, LookupKey.String, undefined, {}, 'ABC');     
        testWithParser('ABC', undefined!, LookupKey.String, undefined, { disableParser: false}, 'ABC');           
        
        testWithParser('ABC', LookupKey.String, undefined, parserFnTrimString, {}, 'ABC!');
        testWithParser('ABC', undefined!, undefined, parserFnTrimString, {}, 'ABC!');
        testWithParser(' ABC ', LookupKey.String, undefined, parserFnTrimString, {}, 'ABC!');     
        testWithParser(' ABC ', undefined!, undefined, parserFnTrimString, {}, 'ABC!');     
        testWithParser('ABC', LookupKey.String, LookupKey.String, parserFnTrimString, {}, 'ABC!');     
        testWithParser('ABC', null!, LookupKey.String, parserFnTrimString, {}, 'ABC!');         
        testWithParser('ABC', undefined!, undefined, parserFnTrimString, { disableParser: false }, 'ABC!');     
        testWithParser('ABC', undefined!, LookupKey.String, parserFnTrimString, { disableParser: false}, 'ABC!');           
    });
    test('As a string representing a number with dataType=number, expecting to parse and update native value. None will generate errors', () => {
        testWithParser('10', LookupKey.Number, undefined, undefined, {}, 10);
        testWithParser(' 20 ', LookupKey.Number, undefined, undefined, {}, 20);     
        testWithParser('30', LookupKey.Number, LookupKey.Number, undefined, {}, 30);        
        testWithParser('30', null!, LookupKey.Number, undefined, {}, 30);           
        testWithParser('30', undefined!, LookupKey.Number, undefined, {}, 30);                
        testWithParser('30', undefined!, LookupKey.Number, undefined, { disableParser: false }, 30);

        testWithParser('10', LookupKey.Number, undefined, parserFnToNumber, {}, 11);
        testWithParser('10', undefined!, undefined, parserFnToNumber, {}, 11);
        testWithParser(' 20 ', LookupKey.Number, undefined, parserFnToNumber, {}, 21);     
        testWithParser(' 20 ', undefined!, undefined, parserFnToNumber, {}, 21);     
        testWithParser('30', LookupKey.Number, LookupKey.Number, parserFnToNumber, {}, 31);        
        testWithParser('30', null!, LookupKey.Number, parserFnToNumber, {}, 31);           
        testWithParser('30', undefined!, LookupKey.Number, parserFnToNumber, { disableParser: false }, 31);                
        testWithParser('30', undefined!, LookupKey.Number, parserFnToNumber, { disableParser: false }, 31);
    });
    test('As a string representing a number with dataType=integer, expecting to parse using fallback lookupkey and update native value. None will generate errors', () => {
        testWithParser('10', LookupKey.Integer, undefined, undefined, {}, 10);
        testWithParser(' 20 ', LookupKey.Integer, undefined, undefined, {}, 20);     
        testWithParser('30', null!, LookupKey.Integer, undefined, {}, 30);        
        testWithParser('30', undefined!, LookupKey.Integer, undefined, {}, 30);

    });    
    test('parserCreator is provided but its supports() will return false. The parserLookupKey or dataType will be used instead.', () => {
        testWithParser('30', undefined!, LookupKey.Integer, parserFnToNumber, {}, 30, false);        
        testWithParser('30', LookupKey.Integer, LookupKey.Integer, parserFnToNumber, {}, 30, false);        
        testWithParser('30', LookupKey.Integer, undefined, parserFnToNumber, {}, 30, false);        
    });

    test('As a string that cannot parse to a number, but using datatype=number, reports an error', () => {
        testWithParserWithErrorMessage('ABC', LookupKey.Number, undefined, undefined, {});
        testWithParserWithErrorMessage('ABC', undefined!, LookupKey.Number, undefined, {});
        testWithParserWithErrorMessage('ABC', LookupKey.Integer, undefined, undefined, {});
        testWithParserWithErrorMessage('ABC', undefined!, LookupKey.Integer, undefined, {});   
        testWithParserWithErrorMessage('ABC', undefined!, LookupKey.Number, parserFnToNumber, {});        
    });

    test('parserLookupKey = null disables parsing, resulting in just updating input value but no change to native value', () => {
        testWithDisabledParser('ABC', LookupKey.String, null, undefined, {});   // parserLookupKey = null
    });
    test('parserCreator is setup and used despite parserLookupKey = null, resulting in just updating input value but no change to native value', () => {
        testWithParser('ABC', LookupKey.String, null, parserFnTrimString, {}, 'ABC!');   
    });    
    test('option.disableParser=true disables parsing, resulting in just updating input value but no change to native value', () => {
        testWithDisabledParser('ABC', LookupKey.String, undefined, undefined, { disableParser: true });
        testWithDisabledParser('ABC', LookupKey.String, undefined, parserFnTrimString, { disableParser: true });
    });   
    test('option.duringEdit=true disables parsing, resulting in just updating input value but no change to native value', () => {
        testWithDisabledParser('ABC', LookupKey.String, undefined, undefined, { duringEdit: true });
        testWithDisabledParser('ABC', LookupKey.String, undefined, parserFnTrimString, { duringEdit: true });
    });        
    test('dataTypeParserService.enabled=false disables parsing, resulting in just updating input value but no change to native value', () => {
        testWithDisabledParser('ABC', LookupKey.String, null, undefined, { }, false);  // parserservice disabled
        testWithDisabledParser('ABC', LookupKey.String, null, parserFnTrimString, { }, false);  // parserservice disabled
    });    
    test('value is not a string disables parsing, resulting in just updating input value but no change to native value', () => {
        testWithDisabledParser(10, LookupKey.Number, undefined, undefined, {}); // not a string
        testWithDisabledParser(false, LookupKey.Number, undefined, undefined, {}); // not a string
        testWithDisabledParser(new Date(), LookupKey.Number, undefined, undefined, {}); // not a string
        testWithDisabledParser(10, LookupKey.Number, undefined, parserFnTrimString, {}); // not a string
        testWithDisabledParser(false, LookupKey.Number, undefined, parserFnTrimString, {}); // not a string
        testWithDisabledParser(new Date(), LookupKey.Number, undefined, parserFnTrimString, {}); // not a string
    });    
    test('Cases that throw exceptions', () => {
        testWithParserWhereErrorIsThrown('ABC', undefined!, undefined, undefined, {}, 'Cannot parse');
        testWithParserWhereErrorIsThrown('ABC', undefined!, undefined, parserFnThrows, {}, 'ERROR');
        testWithParserWhereErrorIsThrown('10', LookupKey.Integer, undefined, (vh) => {
            throw new CodingError('ERROR');
        }, {}, 'ERROR');        
    });
});

describe('InputValueHost.setValues with getInputValue and getValue to check result', () => {
    test('InputValue of "10", Value of 10, options is undefined. Sets both values, IsChanged = true, and does not validate', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValues(10, "10")).not.toThrow();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.valueHost.isChanged).toBe(true);
        expect(setup.valueHost.getValue()).toBe(10);
        expect(setup.valueHost.getInputValue()).toBe("10");
        let changes = setup.validationManager.getHostStateChanges();
        expect(changes.length).toBe(1);
        expect((<InputValueHostInstanceState>changes[0]).value).toBe(10);
        expect((<InputValueHostInstanceState>changes[0]).inputValue).toBe("10");
        expect((<InputValueHostInstanceState>changes[0]).changeCounter).toBe(1);
        expect(setup.valueHost.getConversionErrorMessage()).toBeNull();
    });
    test('InputValue of "10", Value of 10, options is empty object. Sets both values, IsChanged = true, and does not validate', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValues(10, "10", {})).not.toThrow();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.valueHost.isChanged).toBe(true);
        expect(setup.valueHost.getValue()).toBe(10);
        expect(setup.valueHost.getInputValue()).toBe("10");
        let changes = setup.validationManager.getHostStateChanges();
        expect(changes.length).toBe(1);
        expect((<InputValueHostInstanceState>changes[0]).value).toBe(10);
        expect((<InputValueHostInstanceState>changes[0]).inputValue).toBe("10");
        expect((<InputValueHostInstanceState>changes[0]).changeCounter).toBe(1);
    });
    test('InputValue of "10", Value of 10, options is null. Sets both values, IsChanged = true, and does not validate', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValues(10, "10", null!)).not.toThrow();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.valueHost.isChanged).toBe(true);
        expect(setup.valueHost.getValue()).toBe(10);
        expect(setup.valueHost.getInputValue()).toBe("10");
        let changes = setup.validationManager.getHostStateChanges();
        expect(changes.length).toBe(1);
        expect((<InputValueHostInstanceState>changes[0]).value).toBe(10);
        expect((<InputValueHostInstanceState>changes[0]).inputValue).toBe("10");
        expect((<InputValueHostInstanceState>changes[0]).changeCounter).toBe(1);
    });
    test('InputValue of "10", Value of 10, options is { validate: false }. Sets both values, IsChanged = true, and does not validate', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValues(10, "10", { validate: false })).not.toThrow();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.NeedsValidation);
        expect(setup.valueHost.isChanged).toBe(true);
        expect(setup.valueHost.getValue()).toBe(10);
        expect(setup.valueHost.getInputValue()).toBe("10");
        let changes = setup.validationManager.getHostStateChanges();
        expect(changes.length).toBe(1);
        expect((<InputValueHostInstanceState>changes[0]).value).toBe(10);
        expect((<InputValueHostInstanceState>changes[0]).inputValue).toBe("10");
        expect((<InputValueHostInstanceState>changes[0]).changeCounter).toBe(1);
    });
    test('InputValue of "10", Value of 10, options is { validate: true }. Sets both values, IsChanged = true, and validate (no Validators to cause Invalid, so result is Undetermined)', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValues(10, "10", { validate: true })).not.toThrow();
        expect(setup.valueHost.validationStatus).toBe(ValidationStatus.Undetermined);
        expect(setup.valueHost.isChanged).toBe(true);
        expect(setup.valueHost.getValue()).toBe(10);
        expect(setup.valueHost.getInputValue()).toBe("10");
        let changes = setup.validationManager.getHostStateChanges();
        expect(changes.length).toBe(2); // first changes the value; second changes ValidationStatus
        let valueChange = <InputValueHostInstanceState>changes[0];
        expect(valueChange.value).toBe(10);
        expect(valueChange.inputValue).toBe("10");
        let vrChange = <InputValueHostInstanceState>changes[1];
        expect(vrChange.status).toBe(ValidationStatus.Undetermined);
        expect(vrChange.changeCounter).toBe(1);
    });

    test('ConversionErrorTokenValue supplied and is saved because native value is undefined', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValues(undefined, "ABC", { conversionErrorTokenValue: 'ERROR' })).not.toThrow();
        expect(setup.valueHost.getConversionErrorMessage()).toBe('ERROR');
        expect(setup.valueHost.isChanged).toBe(true);
    });
    test('ConversionErrorTokenValue supplied but is not saved because native value is defined', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValues(10, "10", { conversionErrorTokenValue: 'ERROR' })).not.toThrow();
        expect(setup.valueHost.getConversionErrorMessage()).toBeNull();
    });
    test('ConversionErrorTokenValue supplied in one call which saves it but a follow up call without it abandons it', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValues(undefined, { ConversionErrorTokenValue: 'ERROR' })).not.toThrow();
        setup.valueHost.setValues(10, "10", { conversionErrorTokenValue: 'ERROR' });
        expect(setup.valueHost.getConversionErrorMessage()).toBeNull();
    });
    test('ConversionErrorTokenValue and Reset supplied on second call. errorMessage is null and IsChanged is false.', () => {
        let setup = setupInputValueHost();

        expect(() => setup.valueHost.setValues(undefined, { ConversionErrorTokenValue: 'ERROR' })).not.toThrow();
        setup.valueHost.setValues(10, "10", { conversionErrorTokenValue: 'ERROR', reset: true });
        expect(setup.valueHost.getConversionErrorMessage()).toBeNull();
        expect(setup.valueHost.isChanged).toBe(false);
    });
    test('Log call when Level=Debug.', () => {
        const initialValue = 'A';
        const finalValue = 'B';
        let setup = setupInputValueHost({}, { value: initialValue } );
        setup.services.loggerService.minLevel = LoggingLevel.Debug;
        let testItem = setup.valueHost;
        testItem.setValues(finalValue, ' B ');
        let logger = setup.services.loggerService as CapturingLogger;
        expect(logger.findMessage('setValues\\("B", " B "\\)', LoggingLevel.Debug, null)).toBeTruthy();
    });
    test('isEnabled=false will not change the value.', () => {
        const initialValue = 'A';
        const finalValue = 'B';
        let setup = setupInputValueHost({}, { value: initialValue } );
        setup.services.loggerService.minLevel = LoggingLevel.Debug;
        let testItem = setup.valueHost;
        testItem.setEnabled(false);
        testItem.setValues(finalValue, " B ");
        expect(testItem.getValue()).toBe(initialValue);
        let logger = setup.services.loggerService as CapturingLogger;
        expect(logger.findMessage('ValueHost "Field1" disabled.', LoggingLevel.Warn, null)).toBeTruthy();
        expect(logger.findMessage('overrideDisabled', LoggingLevel.Info, null)).toBeNull();
    });
    test('isEnabled=false will change the value when option.overrideDisabled=true.', () => {
        const initialValue = 'A';
        const finalValue = 'B';
        let setup = setupInputValueHost({}, { value: initialValue } );
        setup.services.loggerService.minLevel = LoggingLevel.Debug;
        let testItem = setup.valueHost;
        testItem.setEnabled(false);
        testItem.setValues(finalValue, " B ", { overrideDisabled: true });
        expect(testItem.getValue()).toBe(finalValue);
        let logger = setup.services.loggerService as CapturingLogger;
        expect(logger.findMessage('overrideDisabled', LoggingLevel.Info, null)).toBeTruthy();
        expect(logger.findMessage('ValueHost "Field1" disabled.', LoggingLevel.Warn, null)).toBeNull();
    });    
});

describe('InputValueHost.validate uses autogenerated DataTypeCheck condition', () => {
    test('No conditions at all. DataTypeCheckCondition gets added', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
        ];
        let state: Partial<InputValueHostInstanceState> = {};
        let setup = setupInputValueHostForValidate(ivConfigs, state);
        let logger = setup.services.loggerService as CapturingLogger;
        logger.minLevel = LoggingLevel.Info;
        setup.services.autoGenerateDataTypeCheckService.enabled = true;
        (setup.services.textLocalizerService as TextLocalizerService).registerErrorMessage(ConditionType.DataTypeCheck, null, {
            '*': 'Error Found'
        });

        let onValStateChanged: ValueHostValidationState | null = null;
        setup.validationManager.onValueHostValidationStateChanged = (valueHost, validateResult) => {
            onValStateChanged = validateResult;
        };
        setup.valueHost.setValues(undefined, 'ABC');   // will violate DataTypeCheckCondition
        expect(onValStateChanged).toEqual(
            <ValueHostValidationState>{
                status: ValidationStatus.NeedsValidation,
                issuesFound: null,
                isValid: true,
                doNotSave: true,
                asyncProcessing: false,
                corrected: false,
            });           
        setup.valueHost.validate();
        expect(onValStateChanged).toEqual(
            <ValueHostValidationState>{
                issuesFound: [{
                    errorCode: ConditionType.DataTypeCheck,
                    valueHostName: 'Field1',
                    severity: ValidationSeverity.Severe,    // due to DataTypeCheck
                    errorMessage: 'Error Found',
                    summaryMessage: 'Error Found'
                }],
                isValid: false,
                doNotSave: true,
                asyncProcessing: false,
                status: ValidationStatus.Invalid,
                corrected: false
            }
        );        

        expect(logger.findMessage('Condition for Data Type Check', LoggingLevel.Info, LoggingCategory.Result)).toBeTruthy();
    });
    test('1 condition exists and it is not a DataTypeCheck category. DataTypeCheckCondition gets added', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: AlwaysMatchesConditionType
                }
            }
        ];
        let state: Partial<InputValueHostInstanceState> = {};
        let setup = setupInputValueHostForValidate(ivConfigs, state);
        let logger = setup.services.loggerService as CapturingLogger;
        logger.minLevel = LoggingLevel.Info;
        setup.services.autoGenerateDataTypeCheckService.enabled = true;
        (setup.services.textLocalizerService as TextLocalizerService).registerErrorMessage(ConditionType.DataTypeCheck, null, {
            '*': 'Error Found'
        });

        let onValStateChanged: ValueHostValidationState | null = null;
        setup.validationManager.onValueHostValidationStateChanged = (valueHost, validateResult) => {
            onValStateChanged = validateResult;
        };
        setup.valueHost.setValues(undefined, 'ABC');   // will violate DataTypeCheckCondition
        expect(onValStateChanged).toEqual(
            <ValueHostValidationState>{
                status: ValidationStatus.NeedsValidation,
                issuesFound: null,
                isValid: true,
                doNotSave: true,
                asyncProcessing: false,
                corrected: false,
            });           
        setup.valueHost.validate();
        expect(onValStateChanged).toEqual(
            <ValueHostValidationState>{
                issuesFound: [{
                    errorCode: ConditionType.DataTypeCheck,
                    valueHostName: 'Field1',
                    severity: ValidationSeverity.Severe,    // due to DataTypeCheck
                    errorMessage: 'Error Found',
                    summaryMessage: 'Error Found'
                }],
                isValid: false,
                doNotSave: true,
                asyncProcessing: false,
                status: ValidationStatus.Invalid,
                corrected: false
            }
        );


        expect(logger.findMessage('Condition for Data Type Check', LoggingLevel.Info, LoggingCategory.Result)).toBeTruthy();
    });
    test('1 condition and it is an actual DataTypeCheckCondition. No DataTypeCheckCondition gets added.', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: ConditionType.DataTypeCheck
                },
                errorMessage: null, // so we can use TextLocalizerService
                summaryMessage: null
            }
        ];
        let state: Partial<InputValueHostInstanceState> = {};
        let setup = setupInputValueHostForValidate(ivConfigs, state);
        let logger = setup.services.loggerService as CapturingLogger;
        logger.minLevel = LoggingLevel.Info;
        setup.services.autoGenerateDataTypeCheckService.enabled = true;
        (setup.services.textLocalizerService as TextLocalizerService).registerErrorMessage(ConditionType.DataTypeCheck, null, {
            '*': 'Error Found'
        });

        let onValStateChanged: ValueHostValidationState | null = null;
        setup.validationManager.onValueHostValidationStateChanged = (valueHost, validateResult) => {
            onValStateChanged = validateResult;
        };
        setup.valueHost.setValues(undefined, 'ABC');   // will violate DataTypeCheckCondition
        expect(onValStateChanged).toEqual(
            <ValueHostValidationState>{
                status: ValidationStatus.NeedsValidation,
                issuesFound: null,
                isValid: true,
                doNotSave: true,
                asyncProcessing: false,
                corrected: false,
            });           
        setup.valueHost.validate();
        expect(onValStateChanged).toEqual(
            <ValueHostValidationState>{
                issuesFound: [{
                    errorCode: ConditionType.DataTypeCheck,
                    valueHostName: 'Field1',
                    severity: ValidationSeverity.Severe,
                    errorMessage: 'Error Found',
                    summaryMessage: 'Error Found'
                }],
                isValid: false,
                doNotSave: true,
                asyncProcessing: false,
                status: ValidationStatus.Invalid,
                corrected: false
            }
        );        

        expect(logger.findMessage('Condition for Data Type Check', LoggingLevel.Info, LoggingCategory.Configuration)).toBeNull(); // proves not auto generated
    });

    test('1 condition and it has ConditionCategory=DataTypeCheck. No DataTypeCheckCondition gets added.', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: <RegExpConditionConfig>{
                    conditionType: ConditionType.RegExp,
                    expressionAsString: '^A$', // will match only "A" and we will supply "ABC"
                    category: ConditionCategory.DataTypeCheck
                },
                errorMessage: null, // so we can use TextLocalizerService
                summaryMessage: null
            }
        ];
        let state: Partial<InputValueHostInstanceState> = {};
        let setup = setupInputValueHostForValidate(ivConfigs, state);
        (setup.services.conditionFactory as ConditionFactory).register<RegExpConditionConfig>(
            ConditionType.RegExp, (config) => new RegExpCondition(config));
        let logger = setup.services.loggerService as CapturingLogger;
        logger.minLevel = LoggingLevel.Info;
        setup.services.autoGenerateDataTypeCheckService.enabled = true;
        (setup.services.textLocalizerService as TextLocalizerService).registerErrorMessage(ConditionType.RegExp, null, {
            '*': 'Error Found'
        });
        let onValStateChanged: ValueHostValidationState | null = null;
        setup.validationManager.onValueHostValidationStateChanged = (valueHost, validateResult) => {
            onValStateChanged = validateResult;
        };
        setup.valueHost.setValues('ABC', 'ABC');   // will violate the regexp
        expect(onValStateChanged).toEqual(
            <ValueHostValidationState>{
                status: ValidationStatus.NeedsValidation,
                issuesFound: null,
                isValid: true,
                doNotSave: true,
                asyncProcessing: false,
                corrected: false,
            });           
        setup.valueHost.validate();
        expect(onValStateChanged).toEqual(
            <ValueHostValidationState>{
                issuesFound: [{
                    errorCode: ConditionType.RegExp,
                    valueHostName: 'Field1',
                    severity: ValidationSeverity.Severe,    // due to regexp
                    errorMessage: 'Error Found',
                    summaryMessage: 'Error Found'
                }],
                isValid: false,
                doNotSave: true,
                asyncProcessing: false,
                status: ValidationStatus.Invalid,
                corrected: false
            }
        );        

        expect(logger.findMessage('Condition for Data Type Check', LoggingLevel.Info, LoggingCategory.Configuration)).toBeNull(); // proves not auto generated
    });
    test('Register a DataTypeCheckCondition for PhoneNumber and ensure it gets autogenerated and used', () => {
        const phoneNumberLookupKey = 'PhoneNumber';
        const phoneNumberConditionType = 'PhoneNumber';
        class PhoneNumberDataTypeCheckGenerator implements IDataTypeCheckGenerator {
            supportsValue(dataTypeLookupKey: string): boolean {
                return dataTypeLookupKey === phoneNumberLookupKey;
            }
            createConditions(valueHost: IInputValueHost, dataTypeLookupKey: string, conditionFactory: IConditionFactory): Array<ICondition> {
                return [new RegExpCondition({
                    conditionType: phoneNumberConditionType,
                    expression: /^\d\d\d \d\d\d\-\d{4}$/, // ### ###-####
                    valueHostName: null
                })];
            }

        }
        let services = new MockValidationServices(true, true);
        let logger = services.loggerService as CapturingLogger;
        logger.minLevel = LoggingLevel.Info;
        services.autoGenerateDataTypeCheckService.enabled = true;
        (services.autoGenerateDataTypeCheckService as AutoGenerateDataTypeCheckService).
            register(new PhoneNumberDataTypeCheckGenerator());

        (services.textLocalizerService as TextLocalizerService).
            registerErrorMessage(phoneNumberConditionType, null,
                {
                    '*': 'Error Found'
                });

        let configs: Array<ValueHostConfig> = [
            <InputValueHostConfig>{
                valueHostType: ValueHostType.Input,
                name: 'Field1',
                dataType: phoneNumberLookupKey,
                validatorConfigs: []
            }
        ];

        let onValStateChanged: ValueHostValidationState | null = null;        
        let vmConfig: ValidationManagerConfig = {
            services: services,
            valueHostConfigs: configs,
            onValueHostValidationStateChanged: (valueHost, validateResult) => {
                onValStateChanged = validateResult;
            }
        };
        let vm = new ValidationManager(vmConfig);
        let vh = vm.getValueHost('Field1') as InputValueHost;     
        vh.setValues('ABC', 'ABC');   // will violate the regexp
        expect(onValStateChanged).toEqual(
            <ValueHostValidationState>{
                status: ValidationStatus.NeedsValidation,
                issuesFound: null,
                isValid: true,
                doNotSave: true,
                asyncProcessing: false,
                corrected: false,
            });        
        
        vh.validate();
        expect(onValStateChanged).toEqual(
            <ValueHostValidationState>{
                issuesFound: [{
                    errorCode: phoneNumberConditionType,
                    valueHostName: 'Field1',
                    severity: ValidationSeverity.Severe, // due to regexp
                    errorMessage: 'Error Found',
                    summaryMessage: 'Error Found'
                }],
                isValid: false,
                doNotSave: true,
                asyncProcessing: false,
                status: ValidationStatus.Invalid,
                corrected: false
            });        

        expect(logger.findMessage('PhoneNumber Condition for Data Type Check', LoggingLevel.Info)).toBeTruthy();
    });

});

describe('InputValueHostGenerator members', () => {
    test('CanCreate returns true for ValueHostType.Input', () => {
        let testItem = new InputValueHostGenerator();
        expect(testItem.canCreate(<InputValueHostConfig>{
            valueHostType: ValueHostType.Input,
            name: 'Field1',
            label: '',
            validatorConfigs: null
        })).toBe(true);
    });
    test('CanCreate returns false for unexpected type', () => {
        let testItem = new InputValueHostGenerator();
        expect(testItem.canCreate(<InputValueHostConfig>{
            valueHostType: 'Unexpected',
            name: 'Field1',
            label: '',
            validatorConfigs: null
        })).toBe(false);
    });

    test('CanCreate returns true for Type not defined and presence of ValidationConfig property (using null as a value)', () => {
        let testItem = new InputValueHostGenerator();
        expect(testItem.canCreate(<any>{
            name: 'Field1',
            label: '',
            validatorConfigs: null
        })).toBe(true);
    });
    test('CanCreate returns true for Type not defined and presence of ValidationConfig property using [] as a value', () => {
        let testItem = new InputValueHostGenerator();
        expect(testItem.canCreate(<any>{
            name: 'Field1',
            label: '',
            validatorConfigs: []
        })).toBe(true);
    });
    test('CanCreate returns false for Type not defined and lack of ValidationConfig property', () => {
        let testItem = new InputValueHostGenerator();
        expect(testItem.canCreate(<any>{
            name: 'Field1',
            label: ''
        })).toBe(false);
    });

    test('CanCreate returns false for Type=undefined and lack of ValidationConfig property', () => {
        let testItem = new InputValueHostGenerator();
        expect(testItem.canCreate(<any>{
            Type: undefined,
            name: 'Field1',
            label: ''
        })).toBe(false);
    });

    test('create returns instance of InputValueHost with VM, Config and State established', () => {
        let services = new MockValidationServices(false, false);
        let vm = new MockValidationManager(services);
        let config: InputValueHostConfig = {
            name: 'Field1',
            valueHostType: ValueHostType.Input,
            label: '',
            validatorConfigs: null
        };
        let state: InputValueHostInstanceState = {
            name: 'Field1',
            issuesFound: null,
            status: ValidationStatus.NotAttempted,
            value: undefined,
            inputValue: 'TEST'
        };
        let testItem = new InputValueHostGenerator();
        let vh: IInputValueHost | null = null;
        expect(() => vh = testItem.create(vm, config, state)).not.toThrow();
        expect(vh).not.toBeNull();
        expect(vh).toBeInstanceOf(InputValueHost);
        expect(vh!.getName()).toBe(config.name);    // check Config value
        expect(vh!.getInputValue()).toBe('TEST');  // check instanceState value
    });
});
describe('InputValueHost.requiresInput', () => {
    test('Has a RequireTextCondition. requiresInput returns true', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: ConditionType.RequireText
                }
            }
        ];
        let state: Partial<InputValueHostInstanceState> = {
        };
        let setup = setupInputValueHostForValidate(ivConfigs, state);
        expect(setup.valueHost.requiresInput).toBe(true);
    });
    test('Has a custom condition with Category=Require. requiresInput returns true', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: UserSuppliedResultConditionType,
                    category: ConditionCategory.Require
                }
            }
        ];
        let state: Partial<InputValueHostInstanceState> = {
        };
        let setup = setupInputValueHostForValidate(ivConfigs, state);
        expect(setup.valueHost.requiresInput).toBe(true);
    });    
    test('Lacks a condition with category=Require. requiresInput returns false', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: ConditionType.DataTypeCheck
                }
            }
        ];
        let state: Partial<InputValueHostInstanceState> = {
        };
        let setup = setupInputValueHostForValidate(ivConfigs, state);
        expect(setup.valueHost.requiresInput).toBe(false);
    });
    test('Has a RequireTextCondition but its last amongst several. requiresInput returns true', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            },
            {
                conditionConfig: {
                    conditionType: ConditionType.DataTypeCheck
                }
            },
            {
                conditionConfig: {
                    conditionType: ConditionType.RequireText
                }
            }
        ];
        let state: Partial<InputValueHostInstanceState> = {
        };
        let setup = setupInputValueHostForValidate(ivConfigs, state);
        expect(setup.valueHost.requiresInput).toBe(true);
    });
    test('Has a custom condition with Category=Require but its last amongst several. requiresInput returns true', () => {
        let ivConfigs: Array<Partial<ValidatorConfig>> = [
            {
                conditionConfig: {
                    conditionType: NeverMatchesConditionType
                }
            },
            {
                conditionConfig: {
                    conditionType: ConditionType.DataTypeCheck
                }
            },
            {
                conditionConfig: {
                    conditionType: UserSuppliedResultConditionType,
                    category: ConditionCategory.Require
                }
            }
        ];
        let state: Partial<InputValueHostInstanceState> = {
        };
        let setup = setupInputValueHostForValidate(ivConfigs, state);
        expect(setup.valueHost.requiresInput).toBe(true);
    });    
});

describe('toIInputValueHost function', () => {
    test('Passing actual InputValueHost matches interface returns same object.', () => {
        let vm = new MockValidationManager(new MockValidationServices(false, false));
        let testItem = new InputValueHost(vm, {
            name: 'Field1',
            label: 'Label1',
            validatorConfigs: []
        },
            {
                name: 'Field1',
                value: undefined,
                issuesFound: null,
                status: ValidationStatus.NotAttempted,
                inputValue: undefined
            });
        expect(toIInputValueHost(testItem)).toBe(testItem);
    });
    class TestIInputValueHostImplementation implements IInputValueHost {

        valueHostsManager: IValidationManager = {} as IValidationManager;       
        dispose(): void {}
        gatherValueHostNames(collection: Set<string>, valueHostResolver: IValueHostResolver): void {
            throw new Error("Method not implemented.");
        }


        getInputValue() {
            throw new Error("Method not implemented.");
        }
        setInputValue(value: any, options?: SetValueOptions | undefined): void {
            throw new Error("Method not implemented.");
        }
        setValues(nativeValue: any, inputValue: any, options?: SetValueOptions | undefined): void {
            throw new Error("Method not implemented.");
        }
        otherValueHostChangedNotification(valueHostIdThatChanged: string, revalidate: boolean): void {
            throw new Error("Method not implemented.");
        }
        validate(options?: ValidateOptions | undefined): ValueHostValidateResult {
            throw new Error("Method not implemented.");
        }
        clearValidation(): boolean {
            throw new Error("Method not implemented.");
        }
        isValid: boolean = true;
        validationStatus: ValidationStatus = ValidationStatus.NotAttempted;
        asyncProcessing: boolean = false;
        corrected: boolean = false;
        setBusinessLogicError(error: BusinessLogicError): boolean {
            throw new Error("Method not implemented.");
        }
        clearBusinessLogicErrors(): boolean {
            throw new Error("Method not implemented.");
        }
        get doNotSave(): boolean {
            throw new Error("Method not implemented.");
        }
        getIssueFound(errorCode: string): IssueFound | null {
            throw new Error("Method not implemented.");
        }

        getIssuesFound(group?: string | undefined): IssueFound[] {
            throw new Error("Method not implemented.");
        }
        setIssuesFound(issuesFound: Array<IssueFound>, behavior: SetIssuesFoundErrorCodeMissingBehavior): boolean
        {
            throw new Error('Function not implemented.');
        }        
        getConversionErrorMessage(): string | null {
            throw new Error("Method not implemented.");
        }
        
        getParserLookupKey(): string | null | undefined
        {
            throw new Error("Method not implemented.");
        }        
        requiresInput: boolean = false;
        getName(): string {
            throw new Error("Method not implemented.");
        }
        getLabel(): string {
            throw new Error("Method not implemented.");
        }

        getValue() {
            throw new Error("Method not implemented.");
        }
        setValue(value: any, options?: SetValueOptions | undefined): void {
            throw new Error("Method not implemented.");
        }
        setValueToUndefined(options?: SetValueOptions | undefined): void {
            throw new Error("Method not implemented.");
        }
        getDataType(): string | null {
            throw new Error("Method not implemented.");
        }
        getDataTypeLabel(): string {
            throw new Error("Method not implemented.");
        }

        isChanged: boolean = false;
        saveIntoInstanceState(key: string, value: ValidTypesForInstanceStateStorage | undefined): void {
            throw new Error("Method not implemented.");
        }
        getFromInstanceState(key: string): ValidTypesForInstanceStateStorage | undefined {
            throw new Error("Method not implemented.");
        }
        getValidator(errorCode: string): IValidator | null {
            throw new Error("Method not implemented.");
        }
        isEnabled(): boolean {
            throw new Error("Method not implemented.");
        }
        setEnabled(enabled: boolean): void {
            throw new Error("Method not implemented.");
        }
    }
    test('Passing object with interface match returns same object.', () => {
        let testItem = new TestIInputValueHostImplementation();

        expect(toIInputValueHost(testItem)).toBe(testItem);
    });
    test('PropertyValueHost return null.', () => {
        let vm = new MockValidationManager(new MockValidationServices(false, false));
        let testItem = new PropertyValueHost(vm, {
                name: 'Field1',
                label: 'Label1',
                validatorConfigs: []
            },
            {
                name: 'Field1',
                value: undefined,
                issuesFound: null,
                status: ValidationStatus.NotAttempted
            });
        expect(toIInputValueHost(testItem)).toBeNull();
    });      
    test('StaticValueHost return null.', () => {
        let vm = new MockValidationManager(new MockValidationServices(false, false));
        let testItem = new StaticValueHost(vm, {
                name: 'Field1',
                label: 'Label1'
            },
            {
                name: 'Field1',
                value: undefined
            });
        expect(toIInputValueHost(testItem)).toBeNull();
    });            
    test('CalcValueHost return null.', () => {
        let vm = new MockValidationManager(new MockValidationServices(false, false));
        let testItem = new CalcValueHost(vm, {
                name: 'Field1',
                label: 'Label1',
                calcFn: (host, manager)=> 0
            },
            {
                name: 'Field1',
                value: undefined
            });
        expect(toIInputValueHost(testItem)).toBeNull();
    });            
    test('Non-matching interface returns null.', () => {
        let testItem = {};
        expect(toIInputValueHost(testItem)).toBeNull();
    });
    test('null returns null.', () => {
        expect(toIInputValueHost(null)).toBeNull();
    });
    test('Non-object returns null.', () => {
        expect(toIInputValueHost(100)).toBeNull();
    });
});

describe('toIInputValueHostCallbacks function', () => {
    test('Passing actual InputValueHost matches interface returns same object.', () => {
        let testItem = new MockValidationManager(new MockValidationServices(false, false));

        expect(toIInputValueHostCallbacks(testItem)).toBe(testItem);
    });
    class TestIInputValueHostCallbacksImplementation implements IInputValueHostCallbacks {
        onValueChanged(vh: IValueHost, old: any) { }
        onValueHostInstanceStateChanged(vh: IValueHost, state: ValueHostInstanceState) { }
        onInputValueChanged(vh: IValidatableValueHostBase, old: any) { }
        onValueHostValidationStateChanged(vh: IValidatableValueHostBase, validationState: ValueHostValidationState) { }
    }
    test('Passing object with interface match returns same object.', () => {
        let testItem = new TestIInputValueHostCallbacksImplementation();

        expect(toIInputValueHostCallbacks(testItem)).toBe(testItem);
    });
    test('Non-matching interface returns null.', () => {
        let testItem = {};
        expect(toIInputValueHostCallbacks(testItem)).toBeNull();
    });
    test('null returns null.', () => {
        expect(toIInputValueHostCallbacks(null)).toBeNull();
    });
    test('Non-object returns null.', () => {
        expect(toIInputValueHostCallbacks(100)).toBeNull();
    });
});