import {
    DataTypeCheckCondition, RequireTextCondition, RegExpCondition, RangeCondition,
    EqualToCondition, StringLengthConditionConfig, StringLengthCondition, AllMatchCondition, AllMatchConditionConfig, AnyMatchCondition,
    AnyMatchConditionConfig, CountMatchesCondition, CountMatchesConditionConfig, GreaterThanCondition, GreaterThanOrEqualCondition, LessThanCondition,
    LessThanOrEqualCondition, NotEqualToCondition, NotNullCondition, NotNullConditionConfig,
    GreaterThanOrEqualConditionConfig,
    LessThanOrEqualConditionConfig,
    GreaterThanConditionConfig,
    LessThanConditionConfig,
    NotEqualToConditionConfig,
    EqualToConditionConfig,
    EqualToValueCondition,
    EqualToValueConditionConfig,
    GreaterThanOrEqualValueCondition,
    GreaterThanOrEqualValueConditionConfig,
    GreaterThanValueCondition,
    LessThanOrEqualValueCondition,
    LessThanOrEqualValueConditionConfig,
    LessThanValueCondition,
    LessThanValueConditionConfig,
    NotEqualToValueCondition,
    NotEqualToValueConditionConfig,
    GreaterThanValueConditionConfig,
    PositiveCondition,
    PositiveConditionConfig,
    IntegerCondition,
    IntegerConditionConfig,
    MaxDecimalsCondition,
    MaxDecimalsConditionConfig
} from "@plblum/jivs-engine/build/Conditions/ConcreteConditions";

import { NotCondition, NotConditionConfig } from "@plblum/jivs-engine/build/Conditions/NotCondition";
import { WhenCondition, WhenConditionConfig } from "@plblum/jivs-engine/build/Conditions/WhenCondition";

import { ConditionFactory } from "@plblum/jivs-engine/build/Conditions/ConditionFactory";
import { ConditionType } from "@plblum/jivs-engine/build/Conditions/ConditionTypes";
import {
    StringFormatter, NumberFormatter, IntegerFormatter, DateFormatter, AbbrevDOWDateFormatter, AbbrevDateFormatter,
    BooleanFormatter, CapitalizeStringFormatter, CurrencyFormatter, DateTimeFormatter, LongDOWDateFormatter, LongDateFormatter,
    LowercaseStringFormatter, Percentage100Formatter, PercentageFormatter, TimeofDayFormatter, TimeofDayHMSFormatter, UppercaseStringFormatter
} from "@plblum/jivs-engine/build/DataTypes/DataTypeFormatters";
import { LoggingLevel } from "@plblum/jivs-engine/build/Interfaces/LoggerService";
import { AutoGenerateDataTypeCheckService } from "@plblum/jivs-engine/build/Services/AutoGenerateDataTypeCheckService";
import { ConsoleLoggerService } from "@plblum/jivs-engine/build/Services/ConsoleLoggerService";
import { DataTypeComparerService } from "@plblum/jivs-engine/build/Services/DataTypeComparerService";
import { DataTypeConverterService } from "@plblum/jivs-engine/build/Services/DataTypeConverterService";
import { DataTypeFormatterService } from "@plblum/jivs-engine/build/Services/DataTypeFormatterService";
import { DataTypeIdentifierService } from "@plblum/jivs-engine/build/Services/DataTypeIdentifierService";
import { MessageTokenResolverService } from "@plblum/jivs-engine/build/Services/MessageTokenResolverService";
import { TextLocalizerService } from "@plblum/jivs-engine/build/Services/TextLocalizerService";
import { ValidationServices } from "@plblum/jivs-engine/build/Services/ValidationServices";
import { DataTypeCheckConditionConfig, RequireTextConditionConfig, RegExpConditionConfig, RangeConditionConfig } from "@plblum/jivs-engine/build/Conditions/ConcreteConditions";
import { ITextLocalizerService } from "@plblum/jivs-engine/build/Interfaces/TextLocalizerService";
import { LookupKey } from "@plblum/jivs-engine/build/DataTypes/LookupKeys";
import { CultureIdFallback, ICultureService } from "@plblum/jivs-engine/build/Interfaces/CultureService";
import { DataTypeParserService } from "@plblum/jivs-engine/build/Services/DataTypeParserService";
import { CleanUpStringParser, NumberParser } from "@plblum/jivs-engine/build/DataTypes/DataTypeParsers";
import { IDataTypeParserService } from "@plblum/jivs-engine/build/Interfaces/DataTypeParserService";
import { ValidatorConfigMergeService, ValueHostConfigMergeService } from "@plblum/jivs-engine/build/Services/ConfigMergeService";
import { ValidationManagerConfigBuilderFactory } from "@plblum/jivs-engine/build/Services/ManagerConfigBuilderFactory";
import { ValidationManagerConfigModifierFactory } from "@plblum/jivs-engine/build/Services/ManagerConfigModifierFactory";
import { UTCDateOnlyConverter } from "@plblum/jivs-engine/build/DataTypes/DataTypeConverters";
import { IConditionFactory } from "@plblum/jivs-engine/build/Interfaces/Conditions";



export function createValidationServicesForTesting(): ValidationServices {
    let vs = new ValidationServices();
    registerCultures(vs.cultureService);

    vs.conditionFactory = createConditionFactory();

    // vs.valueHostFactory = unnecessary because uses ValueHostFactory with all ValueHostGenerators by default.

    let dtis = new DataTypeIdentifierService();
    vs.dataTypeIdentifierService = dtis;
    registerDataTypeIdentifiers(dtis);

    let dtfs = new DataTypeFormatterService();
    vs.dataTypeFormatterService = dtfs;
    registerDataTypeFormatters(dtfs);

    let dtcs = new DataTypeConverterService();
    vs.dataTypeConverterService = dtcs;
    registerDataTypeConverters(dtcs);
    
    let dtcmps = new DataTypeComparerService();
    vs.dataTypeComparerService = dtcmps;
    registerDataTypeComparers(dtcmps);    


    let dtps = new DataTypeParserService();
    vs.dataTypeParserService = dtps;
    registerDataTypeParsers(dtps);
    
    let ag = new AutoGenerateDataTypeCheckService();
    vs.autoGenerateDataTypeCheckService = ag;
    registerDataTypeCheckGenerators(ag);    

    vs.textLocalizerService = createTextLocalizerService();
    vs.loggerService = new ConsoleLoggerService(LoggingLevel.Error);
    vs.messageTokenResolverService = new MessageTokenResolverService();
    vs.valueHostConfigMergeService = new ValueHostConfigMergeService();
    vs.validatorConfigMergeService = new ValidatorConfigMergeService();
    vs.managerConfigBuilderFactory = new ValidationManagerConfigBuilderFactory();
    vs.managerConfigModifierFactory = new ValidationManagerConfigModifierFactory();

    return vs;
}

export function createConditionFactory(): ConditionFactory
{
    let cf = new ConditionFactory();
    registerConditions(cf);
    return cf;
}
export function registerConditions(cf: ConditionFactory): void
{
    cf.register<DataTypeCheckConditionConfig>(
        ConditionType.DataTypeCheck, (config) => new DataTypeCheckCondition(config));
    cf.register<RequireTextConditionConfig>(
        ConditionType.RequireText, (config) => new RequireTextCondition(config));
/*    
    cf.register<RegExpConditionConfig>(
        ConditionType.RegExp, (config) => new RegExpCondition(config));
    cf.register<RangeConditionConfig>(
        ConditionType.Range, (config) => new RangeCondition(config));
    cf.register<CompareToConditionConfig>(
        ConditionType.EqualTo, (config) => new EqualToCondition(config));
    cf.register<CompareToConditionConfig>
        (ConditionType.NotEqualTo, (config) => new NotEqualToCondition(config));
    cf.register<CompareToConditionConfig>
        (ConditionType.GreaterThan, (config) => new GreaterThanCondition(config));
    cf.register<CompareToConditionConfig>
        (ConditionType.LessThan, (config) => new LessThanCondition(config));
    cf.register<CompareToConditionConfig>
        (ConditionType.GreaterThanOrEqual, (config) => new GreaterThanOrEqualCondition(config));
    cf.register<CompareToConditionConfig>
        (ConditionType.LessThanOrEqual, (config) => new LessThanOrEqualCondition(config));
    cf.register<StringLengthConditionConfig>
        (ConditionType.StringLength, (config) => new StringLengthCondition(config));
    cf.register<AllMatchConditionConfig>
        (ConditionType.And, (config) => new AllMatchCondition(config));
    cf.register<AnyMatchConditionConfig>
        (ConditionType.Or, (config) => new AnyMatchCondition(config));
    cf.register<CountMatchesConditionConfig>
        (ConditionType.CountMatches, (config) => new CountMatchesCondition(config));
    cf.register<NotNullConditionConfig>(
        ConditionType.NotNull, (config) => new NotNullCondition(config));
    // aliases for users who don't deal well with boolean logic can relate
    cf.register<AllMatchConditionConfig>
        (ConditionType.All, (config) => new AllMatchCondition(config));
    cf.register<AnyMatchConditionConfig>
        (ConditionType.Any, (config) => new AnyMatchCondition(config));
    cf.register<NotConditionConfig>
        (ConditionType.Not, (config) => new NotCondition(config));
    cf.register<WhenConditionConfig>
        (ConditionType.When, (config) => new WhenCondition(config));

*/    
}
export function registerAllConditions(cf: IConditionFactory): void
{
    cf.register<DataTypeCheckConditionConfig>(
        ConditionType.DataTypeCheck, (config) => new DataTypeCheckCondition(config));
    cf.register<RequireTextConditionConfig>(
        ConditionType.RequireText, (config) => new RequireTextCondition(config));
  
    cf.register<RegExpConditionConfig>(
        ConditionType.RegExp, (config) => new RegExpCondition(config));
    cf.register<RangeConditionConfig>(
        ConditionType.Range, (config) => new RangeCondition(config));
    cf.register<EqualToConditionConfig>(
        ConditionType.EqualTo, (config) => new EqualToCondition(config));
    cf.register<NotEqualToConditionConfig>
        (ConditionType.NotEqualTo, (config) => new NotEqualToCondition(config));
    cf.register<GreaterThanConditionConfig>
        (ConditionType.GreaterThan, (config) => new GreaterThanCondition(config));
    cf.register<LessThanConditionConfig>
        (ConditionType.LessThan, (config) => new LessThanCondition(config));
    cf.register<GreaterThanOrEqualConditionConfig>
        (ConditionType.GreaterThanOrEqual, (config) => new GreaterThanOrEqualCondition(config));
    cf.register<LessThanOrEqualConditionConfig>
        (ConditionType.LessThanOrEqual, (config) => new LessThanOrEqualCondition(config));
    cf.register<EqualToValueConditionConfig>(
        ConditionType.EqualToValue, (config) => new EqualToValueCondition(config));
    cf.register<NotEqualToValueConditionConfig>
        (ConditionType.NotEqualToValue, (config) => new NotEqualToValueCondition(config));
    cf.register<GreaterThanValueConditionConfig>
        (ConditionType.GreaterThanValue, (config) => new GreaterThanValueCondition(config));
    cf.register<LessThanValueConditionConfig>
        (ConditionType.LessThanValue, (config) => new LessThanValueCondition(config));
    cf.register<GreaterThanOrEqualValueConditionConfig>
        (ConditionType.GreaterThanOrEqualValue, (config) => new GreaterThanOrEqualValueCondition(config));
    cf.register<LessThanOrEqualValueConditionConfig>
        (ConditionType.LessThanOrEqualValue, (config) => new LessThanOrEqualValueCondition(config));    
    
    cf.register<StringLengthConditionConfig>
        (ConditionType.StringLength, (config) => new StringLengthCondition(config));
    cf.register<AllMatchConditionConfig>
        (ConditionType.And, (config) => new AllMatchCondition(config));
    cf.register<AnyMatchConditionConfig>
        (ConditionType.Or, (config) => new AnyMatchCondition(config));
    cf.register<AllMatchConditionConfig>
        (ConditionType.All, (config) => new AllMatchCondition(config));
    cf.register<AnyMatchConditionConfig>
        (ConditionType.Any, (config) => new AnyMatchCondition(config));
    cf.register<CountMatchesConditionConfig>
        (ConditionType.CountMatches, (config) => new CountMatchesCondition(config));
    cf.register<NotNullConditionConfig>(
        ConditionType.NotNull, (config) => new NotNullCondition(config));
    cf.register<PositiveConditionConfig>
        (ConditionType.Positive, (config) => new PositiveCondition(config));  
    cf.register<IntegerConditionConfig>
        (ConditionType.Integer, (config) => new IntegerCondition(config));
    cf.register<MaxDecimalsConditionConfig>
        (ConditionType.MaxDecimals, (config) => new MaxDecimalsCondition(config));
    cf.register<NotConditionConfig>
        (ConditionType.Not, (config) => new NotCondition(config));
    cf.register<WhenConditionConfig>
        (ConditionType.When, (config) => new WhenCondition(config));

}


/**
 * Cultures that you want to localize. 
 * -> Create an array of CultureIdFallback objects in configureCultures()
 */
export function registerCultures(cs: ICultureService): void
{
    cs.activeCultureId = 'en';    
    let cultures: Array<CultureIdFallback> = [
            {
                cultureId: 'en',
                fallbackCultureId: null    // when this is the default culture,
            },
            {
                cultureId: 'en-US',
                fallbackCultureId: 'en'
            },
            {
                cultureId: 'es',
                fallbackCultureId: 'en'
            },
            {
                cultureId: 'es-MX',
                fallbackCultureId: 'es'
            },
            {
                cultureId: 'fr',
                fallbackCultureId: 'en'
            }
    ];
    cultures.forEach((culture) => cs.register(culture));
}


export function registerDataTypeIdentifiers(dtis: DataTypeIdentifierService): void
{
}

export function registerDataTypeFormatters(dtfs: DataTypeFormatterService): void
{
    dtfs.register(new StringFormatter());
    dtfs.register(new NumberFormatter());     // options?: Intl.NumberFormatOptions
    dtfs.register(new IntegerFormatter());    // options?: Intl.NumberFormatOptions
    dtfs.register(new DateFormatter());       // options?: Intl.DateTimeFormatOptions
    dtfs.register(new CapitalizeStringFormatter());
    dtfs.register(new UppercaseStringFormatter());
    dtfs.register(new LowercaseStringFormatter());
    dtfs.register(new DateTimeFormatter());       // options?: Intl.DateTimeFormatOptions
    dtfs.register(new AbbrevDateFormatter());     // options?: Intl.DateTimeFormatOptions
    dtfs.register(new AbbrevDOWDateFormatter());  // options?: Intl.DateTimeFormatOptions
    dtfs.register(new LongDateFormatter());       // options?: Intl.DateTimeFormatOptions
    dtfs.register(new LongDOWDateFormatter());    // options?: Intl.DateTimeFormatOptions
    dtfs.register(new TimeofDayFormatter());      // options?: Intl.DateTimeFormatOptions
    dtfs.register(new TimeofDayHMSFormatter());   // options?: Intl.DateTimeFormatOptions
    dtfs.register(new CurrencyFormatter('USD'));  // set this to your currency code
    // defaultCurrencyCode: 'USD', options?: Intl.NumberFormatOptions, cultureToCurrencyCode? { 'en-US' : 'USD', 'es-SP': 'EUR' }

    dtfs.register(new PercentageFormatter());     // options?: Intl.NumberFormatOptions
    dtfs.register(new Percentage100Formatter());  // options?: Intl.NumberFormatOptions
    // NOTE: BooleanFormatter has its strings localized in ValidationServices.TextLocalizerService
    // connected to the TrueLabell10n and FalseLabell10n properties.
    dtfs.register(new BooleanFormatter(LookupKey.Boolean)); // "true" and "false"
   // Example of providing another set of labels for true/false by supplying a different lookup key
    dtfs.register(new BooleanFormatter(LookupKey.YesNoBoolean, 'yes', 'no'));     
}

/**
 * Give data types ways to convert their values.
 * Usually these convert their values to a number, string, or Date object.
 * Conditions compare two values automatically when they are number, string, or Date object.
 *    -> Use classes that implement IDataTypeConverter in register()
 * see \examples\ folder for numerous examples of custom DataTypeConverters.
 * @param dtcs 
 */
export function registerDataTypeConverters(dtcs: DataTypeConverterService): void
{
    dtcs.register(new UTCDateOnlyConverter());
}
export function registerDataTypeComparers(dtcs: DataTypeComparerService): void
{ 
}

export function registerDataTypeParsers(dtps: IDataTypeParserService): void {
    // minimal support. Just handling String and Number lookup keys.
    // string trimming
    dtps.register(new CleanUpStringParser(LookupKey.String, { trim: true }));
    
    // any number in US format
    dtps.register(new NumberParser(['en', 'en-US'], {
        decimalSeparator: '.',
        negativeSymbol: '-'
    }));
}

export function registerDataTypeCheckGenerators(ag: AutoGenerateDataTypeCheckService): void
{
}


export function createTextLocalizerService(): ITextLocalizerService
{
    let service = new TextLocalizerService();

    return service;
    
}
