import { ValueHostName } from '@plblum/jivs-engine/build/DataTypes/BasicTypes';
import { RegExpCondition, RegExpConditionConfig } from "@plblum/jivs-engine/build/Conditions/ConcreteConditions";
import { ConditionFactory } from "@plblum/jivs-engine/build/Conditions/ConditionFactory";
import { ConditionCategory, IConditionFactory, ICondition } from "@plblum/jivs-engine/build/Interfaces/Conditions";
import { IDataTypeCheckGenerator } from "@plblum/jivs-engine/build/Interfaces/DataTypeCheckGenerator";
import { IInputValueHost } from "@plblum/jivs-engine/build/Interfaces/InputValueHost";
import { IValidationServices } from "@plblum/jivs-engine/build/Interfaces/ValidationServices";
import { AutoGenerateDataTypeCheckService } from "@plblum/jivs-engine/build/Services/AutoGenerateDataTypeCheckService";
import {
    FluentConditionBuilder, FluentValidatorBuilder, FluentValidatorConfig,
    finishFluentConditionBuilder, finishFluentValidatorBuilder
} from "@plblum/jivs-engine/build/ValueHosts/Fluent";

// Example: Introduce a new Data Type Lookup Key for Email Address.
// This data type is based on a string but has a specific pattern.
// 1. Need to declare a new Data Type Lookup Key. It will be used
//    within the following code and assigned to the dataType property
//    on the InputValueHostConfig (the object that describes
//    a single input value from your UI.)
// 2. Implement a Condition class that uses a regular expression.
//    We'll just subclass RegExpCondition itself and have it configure
//    the regular expression. Set its category property to DataTypeCheck.
// 3. Register that Condition class with ValidationServices.conditionFactory.
// 4. Implement IDataTypeCheckGenerator to auto generate our new Condition class
//    when Jivs needs a Data Type Check Condition for the Lookup Key we've created.
// 5. Register the IDataTypeCheckGenerator withi ValidationServices.autoGenerateDataTypeCheckService.
// 6. OPTIONAL Extend the fluent syntax by using TypeScript Declaration Merging on types:
//    FluentValidatorBuilder, FluentConditionBuilder.


export const emailAddressLookupKey = 'EmailAddress';
export const emailAddressConditionType = 'EmailAddressRegExp';  // this can be anything so long as its different from other ConditionTypes

export class EmailAddressCondition extends RegExpCondition
{
    constructor(config: RegExpConditionConfig)
    {
        super({ ...config, expression: /^([\w\.!#\$%\-+.'_]+@[A-Za-z0-9\-]+(\.[A-Za-z0-9\-]{2,})+)/i });
    }
    public get conditionType(): string {
        return emailAddressConditionType; 
    }
    public get category(): ConditionCategory {
        return ConditionCategory.DataTypeCheck;
    }
}

export class EmailAddressDataTypeCheckGenerator implements IDataTypeCheckGenerator
{
    public supportsValue(dataTypeLookupKey: string): boolean {
        return dataTypeLookupKey.toLowerCase() === emailAddressLookupKey.toLowerCase();
    }
    createConditions(valueHost: IInputValueHost, dataTypeLookupKey: string, conditionFactory: IConditionFactory): Array<ICondition> {
        let config: RegExpConditionConfig = {
            conditionType: emailAddressConditionType,
            valueHostName: valueHost.getName()
        };
        return [
            new EmailAddressCondition(config)   // or use the conditionFactory, so long as your condition is registered
        ];
    }
}

// Register after you have a ValidationService instance. Setup only on the ValidationService
export function registerEmailAddress(validationServices: IValidationServices): void
{
    let cf = validationServices.conditionFactory as ConditionFactory;
    // or move just this line into registerDataTypeCheckGenerators() function     
    cf.register<RegExpConditionConfig>(emailAddressConditionType, (config) => new EmailAddressCondition(config)); 

    let ag = validationServices.autoGenerateDataTypeCheckService as AutoGenerateDataTypeCheckService;
    // or move just this line into registerConditions() function 
    ag.register(new EmailAddressDataTypeCheckGenerator());
}

//#region fluent syntax
// TypeScript Declaration Merging with FluentValidatorBuilder and FluentConditionBuilder
declare module "@plblum/jivs-engine/build/ValueHosts/Fluent"
{
    export interface FluentValidatorBuilder {
        emailAddress(
            errorMessage?: string | null,
            validatorParameters?: FluentValidatorConfig): FluentValidatorBuilder;
    }
    export interface FluentConditionBuilder {
        emailAddress(valueHostName?: ValueHostName): FluentConditionBuilder;
    }
}

/**
 * Common code to setup EmailAddressConditionConfig for support within
 * FluentValidatorBuilder and FluentConditionBuilder fluent functions.
 * @internal
 */
export function _genDCEmailAddress(): RegExpConditionConfig {
    return {} as RegExpConditionConfig;
}

function emailAddressForCondition(valueHostName?: ValueHostName): FluentConditionBuilder {
    return finishFluentConditionBuilder(this,
        emailAddressConditionType, _genDCEmailAddress(), valueHostName);
}
function emailAddressForValidator(
    errorMessage?: string | null,
    validatorParameters?: FluentValidatorConfig): FluentValidatorBuilder {    
    return finishFluentValidatorBuilder(this,
        emailAddressConditionType, _genDCEmailAddress(),
        errorMessage, validatorParameters);
}

// Always need this to execute once during app startup
FluentValidatorBuilder.prototype.emailAddress = emailAddressForValidator;
FluentConditionBuilder.prototype.emailAddress = emailAddressForCondition;

//#endregion fluent syntax