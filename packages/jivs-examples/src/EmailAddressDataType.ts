import { RegExpCondition, RegExpConditionDescriptor } from "@plblum/jivs-engine/src/Conditions/ConcreteConditions";
import { ConditionFactory } from "@plblum/jivs-engine/src/Conditions/ConditionFactory";
import { ConditionCategory, IConditionFactory, ICondition } from "@plblum/jivs-engine/src/Interfaces/Conditions";
import { IDataTypeCheckGenerator } from "@plblum/jivs-engine/src/Interfaces/DataTypeCheckGenerator";
import { IInputValueHost } from "@plblum/jivs-engine/src/Interfaces/InputValueHost";
import { IValidationServices } from "@plblum/jivs-engine/src/Interfaces/ValidationServices";
import { AutoGenerateDataTypeCheckService } from "@plblum/jivs-engine/src/Services/AutoGenerateDataTypeCheckService";

// Example: Introduce a new Data Type Lookup Key for Email Address.
// This data type is based on a string but has a specific pattern.
// 1. Need to declare a new Data Type Lookup Key. It will be used
//    within the following code and assigned to the DataType property
//    on the InputValueHostDescriptor (the object that describes
//    a single input value from your UI.)
// 2. Implement a Condition class that uses a regular expression.
//    We'll just subclass RegExpCondition itself and have it configure
//    the regular expression. Set its category property to DataTypeCheck.
// 3. Register that Condition class with ValidationServices.conditionFactory.
// 4. Implement IDataTypeCheckGenerator to auto generate our new Condition class
//    when Jivs needs a Data Type Check Condition for the Lookup Key we've created.
// 5. Register the IDataTypeCheckGenerator withi ValidationServices.autoGenerateDataTypeCheckService.


export const EmailAddressLookupKey = 'EmailAddress';
export const EmailAddressConditionType = 'EmailAddressRegExp';  // this can be anything so long as its different from other ConditionTypes

export class EmailAddressCondition extends RegExpCondition
{
    constructor(descriptor: RegExpConditionDescriptor)
    {
        super({ ...descriptor, expression: /^([\w\.!#\$%\-+.'_]+@[A-Za-z0-9\-]+(\.[A-Za-z0-9\-]{2,})+)/i });
    }
    public get conditionType(): string {
        return EmailAddressConditionType; 
    }
    public get category(): ConditionCategory {
        return ConditionCategory.DataTypeCheck;
    }
}

export class EmailAddressDataTypeCheckGenerator implements IDataTypeCheckGenerator
{
    public supportsValue(dataTypeLookupKey: string): boolean {
        return dataTypeLookupKey.toLowerCase() === EmailAddressLookupKey.toLowerCase();
    }
    createCondition(valueHost: IInputValueHost, dataTypeLookupKey: string, conditionFactory: IConditionFactory): ICondition | null {
        let descriptor: RegExpConditionDescriptor = {
            type: EmailAddressConditionType,
            valueHostId: valueHost.getId()
        };
        return new EmailAddressCondition(descriptor);   // or use the conditionFactory, so long as your condition is registered
    }
}

// Register after you have a ValidationService instance. Setup only on the ValidationService
export function registerEmailAddress(validationServices: IValidationServices): void
{
    let cf = validationServices.conditionFactory as ConditionFactory;
    // or move just this line into registerDataTypeCheckGenerators() function     
    cf.register<RegExpConditionDescriptor>(EmailAddressConditionType, (descriptor) => new EmailAddressCondition(descriptor)); 

    let ag = validationServices.autoGenerateDataTypeCheckService as AutoGenerateDataTypeCheckService;
    // or move just this line into registerConditions() function 
    ag.register(new EmailAddressDataTypeCheckGenerator());

}